<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Smart Move Pro</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <!-- Leaflet CSS (para el mapa) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    
    <style>
        /* ESTILOS GENERALES */
        :root {
            --bg-color: #121212;
            --surface-color: #1e1e1e;
            --primary-text: #e0e0e0;
            --secondary-text: #a0a0a0;
            --accent-color: #007aff;
            --green: #34c759;
            --red: #ff3b30;
            --blue: #007aff;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            margin: 0;
            background-color: var(--bg-color);
            color: var(--primary-text);
            overscroll-behavior: none;
        }
        .view {
            min-height: 100vh;
            box-sizing: border-box;
        }
        .hidden {
            display: none !important;
        }
        button, select {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 12px 18px;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            margin: 5px;
        }
        select {
             background-color: var(--surface-color);
             border: 1px solid var(--accent-color);
        }
        .control-group {
            padding: 10px;
            background-color: var(--surface-color);
            border-top: 1px solid #333;
        }

        /* VISTA DE CREACIÓN */
        #creationView #map {
            height: 60vh;
            width: 100%;
        }
        #status-message {
            padding: 10px;
            background-color: #333;
            text-align: center;
            font-weight: bold;
        }
        #creation-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* VISTA DE NAVEGACIÓN */
        #navigationView {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            align-items: center;
            text-align: center;
            padding: 20px;
        }
        #deviation-display {
            font-size: 6.5em;
            font-weight: bold;
            font-family: 'Courier New', Courier, monospace;
            flex-grow: 1;
            display: flex;
            align-items: center;
        }
        /* Colores del desvío */
        .on-time { color: var(--green); }
        .delayed { color: var(--red); }
        .ahead { color: var(--blue); }

        #route-info {
            width: 100%;
        }
        #route-name-display {
            font-size: 1.6em;
            font-weight: 500;
        }
        #upcoming-stops-list {
            list-style: none;
            padding: 0;
            margin-top: 15px;
            font-size: 1.1em;
            color: var(--secondary-text);
        }
        #upcoming-stops-list li {
            padding: 5px 0;
        }
        #speed-display {
            font-size: 2.5em;
            font-weight: 600;
            margin-top: 20px;
        }
    </style>
</head>
<body>

    <!-- VISTA 1: CREACIÓN Y SELECCIÓN (visible por defecto) -->
    <div id="creationView" class="view">
        <div id="status-message">Bienvenido a Smart Move Pro</div>
        <div id="map"></div>
        
        <div class="control-group">
            <div id="creation-controls">
                <button id="new-route-btn">Crear Nueva Ruta</button>
                <button id="save-route-btn" class="hidden">Guardar Ruta</button>
                <button id="cancel-creation-btn" class="hidden">Cancelar</button>
            </div>
        </div>

        <div class="control-group">
            <select id="route-selector"></select>
            <button id="start-navigation-btn">Iniciar Recorrido</button>
            <button id="delete-route-btn">Borrar Ruta</button>
        </div>
    </div>

    <!-- VISTA 2: NAVEGACIÓN (oculta por defecto) -->
    <div id="navigationView" class="view hidden">
        <div id="route-info">
            <div id="route-name-display">Nombre del Recorrido</div>
            <ul id="upcoming-stops-list"></ul>
        </div>
        <div id="deviation-display" class="on-time">+00:00</div>
        <div>
            <div id="speed-display">0 km/h</div>
            <button id="stop-navigation-btn">Terminar Recorrido</button>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    
    <script>
    document.addEventListener('DOMContentLoaded', () => {

        // --- REFERENCIAS A ELEMENTOS DEL DOM ---
        const creationView = document.getElementById('creationView');
        const navigationView = document.getElementById('navigationView');
        const statusMessage = document.getElementById('status-message');
        const mapElement = document.getElementById('map');
        const newRouteBtn = document.getElementById('new-route-btn');
        const saveRouteBtn = document.getElementById('save-route-btn');
        const cancelCreationBtn = document.getElementById('cancel-creation-btn');
        const routeSelector = document.getElementById('route-selector');
        const startNavBtn = document.getElementById('start-navigation-btn');
        const deleteRouteBtn = document.getElementById('delete-route-btn');
        const stopNavBtn = document.getElementById('stop-navigation-btn');
        const deviationDisplay = document.getElementById('deviation-display');
        const routeNameDisplay = document.getElementById('route-name-display');
        const upcomingStopsList = document.getElementById('upcoming-stops-list');
        const speedDisplay = document.getElementById('speed-display');

        // --- ESTADO DE LA APLICACIÓN ---
        let map;
        let creationState = 'idle'; // 'idle', 'set_start', 'set_end', 'set_intermediate'
        let tempPoints = [];
        let tempMarkers = [];
        let navigationWatchId = null;
        let currentNavigationRoute = null;
        let currentSegmentIndex = 0;

        // --- INICIALIZACIÓN ---
        function initializeMap() {
            map = L.map(mapElement).setView([-34.6037, -58.3816], 13);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '© OpenStreetMap'
            }).addTo(map);
            map.on('click', handleMapClick);
        }

        // --- LÓGICA DE MANEJO DE VISTAS ---
        function switchView(viewName) {
            creationView.classList.add('hidden');
            navigationView.classList.add('hidden');
            if (viewName === 'creation') {
                creationView.classList.remove('hidden');
            } else {
                navigationView.style.display = 'flex';
                navigationView.classList.remove('hidden');
            }
        }
        
        // --- LÓGICA DE CREACIÓN DE RUTAS ---
        function startRouteCreation() {
            creationState = 'set_start';
            tempPoints = [];
            tempMarkers.forEach(m => m.remove());
            tempMarkers = [];
            statusMessage.textContent = 'Haz clic en el mapa para fijar el PUNTO DE INICIO';
            newRouteBtn.classList.add('hidden');
            saveRouteBtn.classList.remove('hidden');
            cancelCreationBtn.classList.remove('hidden');
        }

        function cancelCreation() {
            creationState = 'idle';
            tempMarkers.forEach(m => m.remove());
            tempMarkers = [];
            tempPoints = [];
            statusMessage.textContent = 'Creación cancelada';
            newRouteBtn.classList.remove('hidden');
            saveRouteBtn.classList.add('hidden');
            cancelCreationBtn.classList.add('hidden');
        }
        
        function handleMapClick(e) {
            if (creationState === 'idle') return;

            const { lat, lng } = e.latlng;
            let point = { lat, lng };
            let marker;

            if (creationState === 'set_start') {
                const time = prompt('Hora de INICIO (formato HH:MM):');
                if (!isValidTime(time)) { alert('Hora inválida. Inténtalo de nuevo.'); return; }
                point.time = time;
                point.name = 'Punto de Inicio';
                marker = L.marker([lat, lng], { icon: createIcon('green') }).addTo(map);
                creationState = 'set_end';
                statusMessage.textContent = 'Ahora, haz clic para fijar el PUNTO FIN';
            } else if (creationState === 'set_end') {
                const time = prompt('Hora de FIN (formato HH:MM):');
                if (!isValidTime(time)) { alert('Hora inválida. Inténtalo de nuevo.'); return; }
                point.time = time;
                point.name = 'Punto Fin';
                marker = L.marker([lat, lng], { icon: createIcon('red') }).addTo(map);
                creationState = 'set_intermediate';
                statusMessage.textContent = 'Opcional: Añade PARADAS INTERMEDIAS. Pulsa Guardar al terminar.';
            } else if (creationState === 'set_intermediate') {
                const name = prompt('Nombre de la parada intermedia:');
                if (!name) return;
                const time = prompt('Hora de la parada (HH:MM) - Déjalo en blanco para autocalcular:');
                if (time && !isValidTime(time)) { alert('Hora inválida. Inténtalo de nuevo.'); return; }
                point.name = name;
                point.time = time || null;
                marker = L.marker([lat, lng], { icon: createIcon('blue') }).addTo(map);
            }
            
            point.type = creationState.replace('set_', '');
            tempPoints.push(point);
            tempMarkers.push(marker);
            marker.bindPopup(`<b>${point.name}</b><br>${point.time || 'A calcular'}`).openPopup();
        }

        function saveRoute() {
            if (tempPoints.length < 2) {
                alert('Debes tener al menos un punto de inicio y un punto fin.');
                return;
            }
            const routeName = prompt('Ingresa un nombre para esta ruta:');
            if (!routeName) {
                alert('El nombre de la ruta no puede estar vacío.');
                return;
            }

            const calculatedPoints = calculateIntermediateTimes(tempPoints);

            const route = {
                id: Date.now(),
                name: routeName,
                stops: calculatedPoints
            };
            
            const routes = getRoutesFromStorage();
            routes.push(route);
            saveRoutesToStorage(routes);
            loadRoutesIntoSelector();
            cancelCreation();
            statusMessage.textContent = `Ruta "${routeName}" guardada!`;
        }
        
        function calculateIntermediateTimes(points) {
            const startPoint = points.find(p => p.type === 'start');
            const endPoint = points.find(p => p.type === 'end');
            let intermediatePoints = points.filter(p => p.type === 'intermediate');

            if (!startPoint || !endPoint) return points;

            // **CORRECCIÓN 1: Ordenar paradas intermedias por su distancia al punto de inicio**
            intermediatePoints.sort((a, b) => {
                const distA = L.latLng(startPoint.lat, startPoint.lng).distanceTo(L.latLng(a.lat, a.lng));
                const distB = L.latLng(startPoint.lat, startPoint.lng).distanceTo(L.latLng(b.lat, b.lng));
                return distA - distB;
            });
            
            const fullPath = [startPoint, ...intermediatePoints, endPoint];
            
            const startTime = parseTimeToDate(startPoint.time);
            const endTime = parseTimeToDate(endPoint.time);
            if (endTime <= startTime) {
                endTime.setDate(endTime.getDate() + 1); // Manejar recorridos que cruzan la medianoche
            }
            const totalDurationMinutes = (endTime - startTime) / 60000;
            
            let totalDistance = 0;
            for (let i = 0; i < fullPath.length - 1; i++) {
                totalDistance += L.latLng(fullPath[i].lat, fullPath[i].lng).distanceTo(L.latLng(fullPath[i+1].lat, fullPath[i+1].lng));
            }

            if(totalDistance === 0) return fullPath;

            let cumulativeDistance = 0;
            for (let i = 1; i < fullPath.length; i++) {
                cumulativeDistance += L.latLng(fullPath[i-1].lat, fullPath[i-1].lng).distanceTo(L.latLng(fullPath[i].lat, fullPath[i].lng));
                
                if (fullPath[i].type === 'intermediate' && !fullPath[i].time) {
                    const distanceRatio = cumulativeDistance / totalDistance;
                    const timeOffsetMinutes = totalDurationMinutes * distanceRatio;
                    const calculatedTime = new Date(startTime.getTime() + timeOffsetMinutes * 60000);
                    fullPath[i].time = `${String(calculatedTime.getHours()).padStart(2, '0')}:${String(calculatedTime.getMinutes()).padStart(2, '0')}`;
                }
            }
            return fullPath;
        }

        // --- LÓGICA DE NAVEGACIÓN ---
        function startNavigation() {
            const selectedRouteId = routeSelector.value;
            if (!selectedRouteId) {
                alert('Por favor, selecciona una ruta para iniciar.');
                return;
            }

            const routes = getRoutesFromStorage();
            currentNavigationRoute = routes.find(r => r.id == selectedRouteId);
            
            if (!currentNavigationRoute) { alert('Ruta no encontrada.'); return; }
            
            currentSegmentIndex = 0;
            switchView('navigation');
            updateNavigationUI();

            const geoOptions = { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 };
            navigationWatchId = navigator.geolocation.watchPosition(handlePositionUpdate, handleGeoError, geoOptions);
        }

        function stopNavigation() {
            if (navigationWatchId) navigator.geolocation.clearWatch(navigationWatchId);
            navigationWatchId = null;
            currentNavigationRoute = null;
            switchView('creation');
        }
        
        function handlePositionUpdate(position) {
            const { latitude, longitude, speed } = position.coords;
            const now = new Date();
            
            updateCurrentSegment(latitude, longitude);

            const stopA = currentNavigationRoute.stops[currentSegmentIndex];
            const stopB = currentNavigationRoute.stops[currentSegmentIndex + 1];

            if (!stopA || !stopB) {
                stopNavigation();
                alert("Recorrido finalizado!");
                return;
            }

            const timeA = parseTimeToDate(stopA.time);
            const timeB = parseTimeToDate(stopB.time);
            if (timeB <= timeA) timeB.setDate(timeB.getDate() + 1);
            if (now.getHours() < timeA.getHours()) now.setDate(now.getDate() + 1);

            const totalSegmentDuration = timeB - timeA;
            const distanceTotalSegment = L.latLng(stopA.lat, stopA.lng).distanceTo(L.latLng(stopB.lat, stopB.lng));
            const distanceToB = L.latLng(latitude, longitude).distanceTo(L.latLng(stopB.lat, stopB.lng));

            let distanceRatio = 0;
            if (distanceTotalSegment > 0) {
                 distanceRatio = 1 - (distanceToB / distanceTotalSegment);
                 distanceRatio = Math.max(0, Math.min(1, distanceRatio));
            }

            const idealTimeAtCurrentPos = new Date(timeA.getTime() + totalSegmentDuration * distanceRatio);
            
            // **CORRECCIÓN 2: Lógica de desvío invertida para que + sea adelantado**
            const deviationInSeconds = Math.round((idealTimeAtCurrentPos - now) / 1000);

            updateNavigationUI(deviationInSeconds, speed);
        }

        function updateCurrentSegment(lat, lng) {
            if (!currentNavigationRoute || currentSegmentIndex >= currentNavigationRoute.stops.length - 1) return;
            
            const nextStop = currentNavigationRoute.stops[currentSegmentIndex + 1];
            const distanceToNextStop = L.latLng(lat, lng).distanceTo(L.latLng(nextStop.lat, nextStop.lng));
            if (distanceToNextStop < 50) currentSegmentIndex++;
        }

        function updateNavigationUI(deviationSeconds, speed) {
            if (deviationSeconds !== undefined) {
                deviationDisplay.textContent = formatSecondsToDeviation(deviationSeconds);
                deviationDisplay.className = 'deviation-display';
                if (deviationSeconds <= -240) { // Atrasado
                    deviationDisplay.classList.add('delayed');
                } else if (deviationSeconds >= 240) { // Adelantado
                    deviationDisplay.classList.add('ahead');
                } else {
                    deviationDisplay.classList.add('on-time');
                }
            }

            const speedKmh = speed ? (speed * 3.6).toFixed(0) : '0';
            speedDisplay.textContent = `${speedKmh} km/h`;
            
            routeNameDisplay.textContent = currentNavigationRoute.name;
            upcomingStopsList.innerHTML = '';
            for (let i = currentSegmentIndex + 1; i < currentNavigationRoute.stops.length; i++) {
                const stop = currentNavigationRoute.stops[i];
                const li = document.createElement('li');
                li.textContent = `${stop.time} - ${stop.name}`;
                upcomingStopsList.appendChild(li);
            }
        }

        function handleGeoError(error) {
            alert(`Error de GPS: ${error.message}`);
            stopNavigation();
        }

        // --- ALMACENAMIENTO LOCAL ---
        function getRoutesFromStorage() {
            return JSON.parse(localStorage.getItem('smartMoveProRoutes')) || [];
        }
        function saveRoutesToStorage(routes) {
            localStorage.setItem('smartMoveProRoutes', JSON.stringify(routes));
        }
        function loadRoutesIntoSelector() {
            const routes = getRoutesFromStorage();
            routeSelector.innerHTML = '<option value="">-- Selecciona una ruta --</option>';
            routes.forEach(route => {
                const option = document.createElement('option');
                option.value = route.id;
                option.textContent = route.name;
                routeSelector.appendChild(option);
            });
        }
        function deleteSelectedRoute() {
            const selectedRouteId = routeSelector.value;
            if (!selectedRouteId) return alert('Selecciona una ruta para borrar.');
            if (confirm(`¿Borrar la ruta "${routeSelector.options[routeSelector.selectedIndex].text}"?`)) {
                let routes = getRoutesFromStorage();
                routes = routes.filter(r => r.id != selectedRouteId);
                saveRoutesToStorage(routes);
                loadRoutesIntoSelector();
                alert('Ruta borrada.');
            }
        }

        // --- FUNCIONES DE AYUDA (helpers) ---
        function isValidTime(timeStr) {
            return timeStr && /^([01]\d|2[0-3]):([0-5]\d)$/.test(timeStr);
        }
        function parseTimeToDate(timeStr) {
            const [hours, minutes] = timeStr.split(':');
            const date = new Date();
            date.setHours(hours, minutes, 0, 0);
            return date;
        }
        function createIcon(color) {
            return new L.Icon({
                iconUrl: `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-${color}.png`,
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
            });
        }
        function formatSecondsToDeviation(seconds) {
            const sign = seconds < 0 ? '-' : '+';
            const absSeconds = Math.abs(seconds);
            const minutes = String(Math.floor(absSeconds / 60)).padStart(2, '0');
            const secs = String(absSeconds % 60).padStart(2, '0');
            return `${sign}${minutes}:${secs}`;
        }

        // --- ASIGNACIÓN DE EVENTOS ---
        newRouteBtn.addEventListener('click', startRouteCreation);
        saveRouteBtn.addEventListener('click', saveRoute);
        cancelCreationBtn.addEventListener('click', cancelCreation);
        startNavBtn.addEventListener('click', startNavigation);
        stopNavBtn.addEventListener('click', stopNavigation);
        deleteRouteBtn.addEventListener('click', deleteSelectedRoute);
        
        // --- INICIO ---
        initializeMap();
        loadRoutesIntoSelector();
    });
    </script>
</body>
</html>
