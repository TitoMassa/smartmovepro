<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Move Pro - Asistente de Conductor</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <style>
        :root {
            --primary-color: #4f46e5; /* indigo-600 */
            --primary-hover: #4338ca; /* indigo-700 */
            --danger-color: #dc2626; /* red-600 */
            --danger-hover: #b91c1c; /* red-700 */
            --success-color: #16a34a; /* green-600 */
            --success-hover: #15803d; /* green-700 */
        }
        #map { height: 400px; width: 100%; cursor: crosshair; border-radius: 0.5rem; }
        .status-indicator {
            font-size: 3rem; font-weight: 800; text-align: center;
            padding: 1.25rem; border-radius: 0.5rem; color: white;
            transition: background-color 0.3s ease;
            letter-spacing: 0.05em;
        }
        .status-ontime { background-color: var(--success-color); }
        .status-late { background-color: var(--danger-color); }
        .status-early { background-color: #2563eb; } /* blue-600 */
        .status-inactive { background-color: #4b5563; } /* gray-600 */
        .stop-item-btn {
            background: none; border: none; cursor: pointer;
            margin-left: 8px; vertical-align: middle;
            transition: color 0.2s;
        }
        .creation-guide {
            background-color: #eef2ff; color: var(--primary-color); border-left: 4px solid var(--primary-color);
            padding: 12px; margin-bottom: 1rem; border-radius: 4px;
            font-weight: 500;
        }
        .btn {
            padding: 0.75rem 1rem; border-radius: 0.375rem; font-weight: 600;
            transition: background-color 0.2s, transform 0.1s;
            display: flex; align-items: center; justify-content: center;
        }
        .btn:active { transform: scale(0.98); }
        .btn-primary { background-color: var(--primary-color); color: white; }
        .btn-primary:hover { background-color: var(--primary-hover); }
        .btn-danger { background-color: var(--danger-color); color: white; }
        .btn-danger:hover { background-color: var(--danger-hover); }
        .btn-success { background-color: var(--success-color); color: white; }
        .btn-success:hover { background-color: var(--success-hover); }
    </style>
</head>
<body class="bg-gray-100 font-sans">

    <div class="container mx-auto p-4 max-w-7xl">

        <header class="bg-white shadow-lg rounded-xl p-6 mb-6 flex justify-between items-center">
            <div>
                <h1 class="text-4xl font-extrabold text-gray-800">Smart Move Pro</h1>
                <p class="text-gray-500 text-lg">Tu asistente de recorrido inteligente</p>
            </div>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-3 gap-6">

            <!-- Columna de Gestión de Recorrido -->
            <div class="lg:col-span-1 bg-white p-6 rounded-xl shadow-lg">
                <h2 class="text-2xl font-bold mb-4 border-b pb-3 text-gray-700">Gestión de Recorrido</h2>
                
                <div class="space-y-4">
                    <div>
                        <label for="recorrido-select" class="block text-sm font-medium text-gray-700 mb-1">Seleccionar Recorrido:</label>
                        <div class="flex items-center space-x-2">
                            <select id="recorrido-select" class="w-full p-2 border border-gray-300 rounded-md shadow-sm"></select>
                            <button id="delete-recorrido-btn" title="Eliminar Recorrido" class="p-2.5 btn btn-danger">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clip-rule="evenodd" /></svg>
                            </button>
                        </div>
                    </div>

                    <div>
                        <label for="radius-input" class="block text-sm font-medium text-gray-700 mb-1">Radio de Parada (metros):</label>
                        <input type="number" id="radius-input" value="20" min="5" class="w-full p-2 border border-gray-300 rounded-md shadow-sm">
                    </div>
                    
                    <div class="flex items-center">
                        <input type="checkbox" id="auto-calc-checkbox" class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                        <label for="auto-calc-checkbox" class="ml-2 block text-sm text-gray-900">Calcular horarios intermedios</label>
                    </div>

                    <div class="flex space-x-2 pt-2">
                        <button id="start-btn" class="flex-1 btn btn-success">Iniciar</button>
                        <button id="stop-btn" class="flex-1 btn btn-danger" disabled>Detener</button>
                    </div>
                    <hr class="my-2">
                    <div>
                        <label for="new-recorrido-name" class="block text-sm font-medium text-gray-700 mb-1">Nombre Nuevo Recorrido:</label>
                        <input type="text" id="new-recorrido-name" placeholder="Ej: Línea 106 - Ramal A" class="w-full p-2 border border-gray-300 rounded-md shadow-sm">
                        <button id="create-recorrido-btn" class="mt-2 w-full btn btn-primary">Crear Recorrido</button>
                    </div>
                    <div>
                        <div id="creation-guide-container" class="hidden"></div>
                        <h3 class="text-lg font-bold mb-2 text-gray-700">Puntos del Recorrido</h3>
                        <ul id="stops-list" class="space-y-2 bg-gray-50 p-3 rounded-md h-48 overflow-y-auto"></ul>
                    </div>
                </div>
            </div>

            <!-- Columna de Mapa y Estado -->
            <div class="lg:col-span-2 bg-white p-6 rounded-xl shadow-lg">
                <h2 class="text-2xl font-bold mb-4 border-b pb-3 text-gray-700">Estado y Mapa</h2>
                <div id="status-indicator" class="status-indicator status-inactive mb-2">--:--</div>
                <p id="current-stop-info" class="text-center text-green-600 font-bold h-6 mb-1 text-xl hidden"></p>
                <p id="next-stop-info" class="text-center text-gray-700 font-semibold h-6 mb-4 text-xl"></p>
                <div id="map" class="shadow-inner"></div>
                <p class="text-xs text-gray-500 mt-2 text-center">Haz clic en el mapa para agregar un punto al recorrido activo.</p>
                
                <div id="eta-container" class="mt-6 hidden">
                    <h3 class="text-xl font-bold text-gray-700 mb-3">Tiempos Estimados (Pasajero)</h3>
                    <div class="overflow-x-auto">
                        <table class="min-w-full bg-white border rounded-lg">
                            <thead class="bg-gray-50">
                                <tr>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Parada</th>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Programado</th>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">ETA</th>
                                </tr>
                            </thead>
                            <tbody id="eta-table-body" class="divide-y divide-gray-200">
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Modal para agregar/editar punto -->
    <div id="stop-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full hidden">
        <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
            <div class="mt-3 text-center">
                <h3 id="modal-title" class="text-lg leading-6 font-medium text-gray-900"></h3>
                <div class="mt-2 px-7 py-3 space-y-4">
                    <div id="point-type-container">
                        <label for="point-type-select" class="block text-sm font-medium text-gray-700 mb-1">Tipo de Punto:</label>
                        <select id="point-type-select" class="w-full p-2 border border-gray-300 rounded-md shadow-sm">
                            <option value="stop">Parada</option>
                            <option value="waypoint">Punto de Paso</option>
                        </select>
                    </div>
                    <div id="point-name-container">
                        <input type="text" id="stop-name" placeholder="Nombre (opcional)" class="w-full p-2 border border-gray-300 rounded-md">
                    </div>
                    <div id="datetime-input-container">
                        <label class="text-sm text-gray-600">Fecha y Hora Programada:</label>
                        <div class="flex space-x-2">
                            <input type="date" id="stop-date" class="w-1/2 p-2 border border-gray-300 rounded-md">
                            <input type="time" id="stop-time" class="w-1/2 p-2 border border-gray-300 rounded-md">
                        </div>
                    </div>
                </div>
                <div class="items-center px-4 py-3">
                    <button id="save-stop-btn" class="w-full btn btn-success">Guardar</button>
                    <button id="cancel-stop-btn" class="mt-2 w-full btn bg-gray-500 hover:bg-gray-600 text-white">Cancelar</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- VARIABLES GLOBALES ---
            let map, driverMarker, currentRecorrido, gpsInterval, timeUpdateInterval, tempStopCoords;
            let recorridos = {};
            let currentDriverLatLng = null;
            let editingStopIndex = null;
            let stopRadius = 20;
            let radiusCircles = [];
            let lastDeviationSeconds = 0;

            // --- ELEMENTOS DEL DOM ---
            const recorridoSelect = document.getElementById('recorrido-select');
            const startBtn = document.getElementById('start-btn');
            const stopBtn = document.getElementById('stop-btn');
            const createRecorridoBtn = document.getElementById('create-recorrido-btn');
            const newRecorridoNameInput = document.getElementById('new-recorrido-name');
            const deleteRecorridoBtn = document.getElementById('delete-recorrido-btn');
            const radiusInput = document.getElementById('radius-input');
            const autoCalcCheckbox = document.getElementById('auto-calc-checkbox');
            const stopsList = document.getElementById('stops-list');
            const statusIndicator = document.getElementById('status-indicator');
            const currentStopInfo = document.getElementById('current-stop-info');
            const nextStopInfo = document.getElementById('next-stop-info');
            const mapElement = document.getElementById('map');
            const creationGuideContainer = document.getElementById('creation-guide-container');
            const etaContainer = document.getElementById('eta-container');
            const etaTableBody = document.getElementById('eta-table-body');
            
            // Modal
            const stopModal = document.getElementById('stop-modal');
            const modalTitle = document.getElementById('modal-title');
            const saveStopBtn = document.getElementById('save-stop-btn');
            const cancelStopBtn = document.getElementById('cancel-stop-btn');
            const pointTypeContainer = document.getElementById('point-type-container');
            const pointTypeSelect = document.getElementById('point-type-select');
            const pointNameContainer = document.getElementById('point-name-container');
            const stopNameInput = document.getElementById('stop-name');
            const datetimeInputContainer = document.getElementById('datetime-input-container');
            const stopDateInput = document.getElementById('stop-date');
            const stopTimeInput = document.getElementById('stop-time');

            // --- INICIALIZACIÓN ---
            function initializeMap() {
                map = L.map(mapElement).setView([-27.46, -58.83], 13);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(map);
                const driverIcon = L.icon({
                    iconUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon-2x.png',
                    iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
                });
                driverMarker = L.marker([0, 0], { icon: driverIcon }).addTo(map).bindPopup("Tu posición");
                map.on('click', onMapClick);
            }

            function loadRecorridosFromStorage() {
                const storedRecorridos = localStorage.getItem('busRecorridos');
                if (storedRecorridos) recorridos = JSON.parse(storedRecorridos);
                updateRecorridoSelector();
            }

            function saveRecorridosToStorage() {
                localStorage.setItem('busRecorridos', JSON.stringify(recorridos));
            }

            // --- GESTIÓN DE RECORRIDOS Y PUNTOS ---
            function updateRecorridoSelector() {
                const currentSelection = recorridoSelect.value;
                recorridoSelect.innerHTML = '<option value="">-- Selecciona un recorrido --</option>';
                for (const recorridoName in recorridos) {
                    const option = document.createElement('option');
                    option.value = recorridoName;
                    option.textContent = recorridoName;
                    recorridoSelect.appendChild(option);
                }
                recorridoSelect.value = currentSelection;
                if (!recorridoSelect.value && Object.keys(recorridos).length > 0) {
                    recorridoSelect.value = Object.keys(recorridos)[0];
                }
                updateUIForSelectedRecorrido();
            }

            function updateUIForSelectedRecorrido() {
                const selectedRecorrido = recorridoSelect.value;
                updateCreationGuide(selectedRecorrido);
                updateStopsList(selectedRecorrido);
                drawRecorridoOnMap(selectedRecorrido);
            }
            
            function formatDateTime(isoString) {
                if (!isoString) return 'N/A';
                const date = new Date(isoString);
                const day = String(date.getDate()).padStart(2, '0');
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                return `${day}/${month} ${hours}:${minutes}`;
            }

            function updateStopsList(recorridoName) {
                stopsList.innerHTML = '';
                const points = recorridos[recorridoName] || [];
                if (points.length === 0) {
                    stopsList.innerHTML = '<li class="text-gray-500">No hay puntos.</li>';
                } else {
                    points.forEach((point, index) => {
                        const li = document.createElement('li');
                        li.className = 'flex justify-between items-center bg-white p-2 rounded-md shadow-sm';
                        const icon = point.type === 'stop' ? '🅿️' : '➡️';
                        const name = point.name || (point.type === 'stop' ? `Parada ${index + 1}` : `Punto ${index + 1}`);
                        li.innerHTML = `
                            <span>${icon} ${name} - ${formatDateTime(point.dateTime)}</span>
                            <div>
                                <button title="Editar Punto" class="stop-item-btn edit-stop-btn text-blue-600" data-index="${index}"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M17.414 2.586a2 2 0 00-2.828 0L7 10.172V13h2.828l7.586-7.586a2 2 0 000-2.828z" /><path fill-rule="evenodd" d="M2 6a2 2 0 012-2h4a1 1 0 010 2H4v10h10v-4a1 1 0 112 0v4a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" clip-rule="evenodd" /></svg></button>
                                <button title="Eliminar Punto" class="stop-item-btn delete-stop-btn text-red-600" data-index="${index}"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clip-rule="evenodd" /></svg></button>
                            </div>`;
                        stopsList.appendChild(li);
                    });
                }
            }

            function updateCreationGuide(recorridoName) {
                const points = recorridos[recorridoName] || [];
                let guideText = '';
                if (recorridoName) {
                    if (points.length === 0) {
                        guideText = '1. Haz clic en el mapa para añadir la <b>primera parada</b>.';
                    } else if (points.length === 1) {
                        guideText = '2. Haz clic para añadir la <b>última parada</b>.';
                    } else {
                        guideText = '3. Añade <b>puntos intermedios</b> o inicia el recorrido.';
                    }
                }
                if (guideText) {
                    creationGuideContainer.innerHTML = `<div class="creation-guide">${guideText}</div>`;
                    creationGuideContainer.classList.remove('hidden');
                } else {
                    creationGuideContainer.classList.add('hidden');
                }
            }

            createRecorridoBtn.addEventListener('click', () => {
                const recorridoName = newRecorridoNameInput.value.trim();
                if (recorridoName && !recorridos[recorridoName]) {
                    recorridos[recorridoName] = [];
                    saveRecorridosToStorage();
                    newRecorridoNameInput.value = '';
                    updateRecorridoSelector();
                    recorridoSelect.value = recorridoName;
                } else {
                    alert(recorridos[recorridoName] ? 'Error: Ya existe un recorrido con ese nombre.' : 'Error: Ingresa un nombre válido.');
                }
            });

            deleteRecorridoBtn.addEventListener('click', () => {
                const recorridoName = recorridoSelect.value;
                if (!recorridoName) return;
                if (confirm(`¿Estás seguro de que quieres eliminar el recorrido "${recorridoName}"?`)) {
                    delete recorridos[recorridoName];
                    saveRecorridosToStorage();
                    recorridoSelect.value = '';
                    updateRecorridoSelector();
                }
            });

            recorridoSelect.addEventListener('change', updateUIForSelectedRecorrido);
            radiusInput.addEventListener('change', () => {
                stopRadius = parseInt(radiusInput.value) || 20;
                drawRecorridoOnMap(recorridoSelect.value);
            });
            autoCalcCheckbox.addEventListener('change', () => {
                if (autoCalcCheckbox.checked) {
                    calculateIntermediateTimes(recorridoSelect.value);
                }
                updateUIForSelectedRecorrido();
            });

            function onMapClick(e) {
                const selectedRecorrido = recorridoSelect.value;
                if (!selectedRecorrido) {
                    alert("Por favor, crea o selecciona un recorrido primero.");
                    return;
                }
                tempStopCoords = e.latlng;
                editingStopIndex = null;
                const points = recorridos[selectedRecorrido];

                if (points.length < 2) {
                    modalTitle.textContent = points.length === 0 ? "Definir Primera Parada" : "Definir Última Parada";
                    pointTypeContainer.style.display = 'none';
                    pointNameContainer.style.display = 'block';
                    datetimeInputContainer.style.display = 'block';
                } else {
                    modalTitle.textContent = "Añadir Punto Intermedio";
                    pointTypeContainer.style.display = 'block';
                    datetimeInputContainer.style.display = autoCalcCheckbox.checked ? 'none' : 'block';
                    toggleNameForWaypoint();
                }
                
                pointTypeSelect.value = 'stop';
                stopNameInput.value = '';
                const now = new Date();
                stopDateInput.value = now.toISOString().slice(0, 10);
                stopTimeInput.value = now.toTimeString().slice(0, 5);
                stopModal.classList.remove('hidden');
            }
            
            pointTypeSelect.addEventListener('change', toggleNameForWaypoint);
            function toggleNameForWaypoint() {
                pointNameContainer.style.display = pointTypeSelect.value === 'waypoint' ? 'none' : 'block';
            }

            saveStopBtn.addEventListener('click', () => {
                const stopName = stopNameInput.value.trim();
                const stopDate = stopDateInput.value;
                const stopTime = stopTimeInput.value;
                const pointType = pointTypeSelect.value;
                const selectedRecorrido = recorridoSelect.value;
                const points = recorridos[selectedRecorrido];
                let dateTime = (stopDate && stopTime) ? `${stopDate}T${stopTime}` : null;

                if (editingStopIndex !== null) {
                    const pointToEdit = points[editingStopIndex];
                    pointToEdit.name = stopName;
                    pointToEdit.dateTime = dateTime;
                    pointToEdit.type = pointType;
                } else {
                    let newPoint;
                    if (points.length < 2) {
                        if (!dateTime) { alert("La fecha y hora son obligatorias."); return; }
                        newPoint = { name: stopName, dateTime: dateTime, type: 'stop', lat: tempStopCoords.lat, lng: tempStopCoords.lng };
                        points.push(newPoint);
                    } else {
                        if (autoCalcCheckbox.checked) dateTime = null;
                        else if (!dateTime) { alert("La fecha y hora son obligatorias si el cálculo automático está desactivado."); return; }
                        newPoint = { name: stopName, dateTime: dateTime, type: pointType, lat: tempStopCoords.lat, lng: tempStopCoords.lng };
                        points.splice(points.length - 1, 0, newPoint);
                    }
                }
                
                if (autoCalcCheckbox.checked) {
                    calculateIntermediateTimes(selectedRecorrido);
                }

                saveRecorridosToStorage();
                updateUIForSelectedRecorrido();
                stopModal.classList.add('hidden');
                editingStopIndex = null;
            });

            cancelStopBtn.addEventListener('click', () => {
                stopModal.classList.add('hidden');
                editingStopIndex = null;
            });

            stopsList.addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if (!button) return;
                const recorridoName = recorridoSelect.value;
                const stopIndex = parseInt(button.dataset.index);

                if (button.classList.contains('edit-stop-btn')) {
                    editingStopIndex = stopIndex;
                    const point = recorridos[recorridoName][stopIndex];
                    modalTitle.textContent = "Editar Punto";
                    stopNameInput.value = point.name;
                    if (point.dateTime) {
                        const date = new Date(point.dateTime);
                        stopDateInput.value = date.toISOString().slice(0, 10);
                        stopTimeInput.value = date.toTimeString().slice(0, 5);
                    }
                    pointTypeSelect.value = point.type || 'stop';
                    
                    const isAuto = autoCalcCheckbox.checked;
                    const isFirstOrLast = stopIndex === 0 || stopIndex === (recorridos[recorridoName].length - 1);
                    datetimeInputContainer.style.display = (!isAuto || isFirstOrLast) ? 'block' : 'none';
                    pointTypeContainer.style.display = (isFirstOrLast) ? 'none' : 'block';
                    toggleNameForWaypoint();
                    stopModal.classList.remove('hidden');
                }
                if (button.classList.contains('delete-stop-btn')) {
                    if (confirm("¿Estás seguro de que quieres eliminar este punto?")) {
                        recorridos[recorridoName].splice(stopIndex, 1);
                        if (autoCalcCheckbox.checked) calculateIntermediateTimes(recorridoName);
                        saveRecorridosToStorage();
                        updateUIForSelectedRecorrido();
                    }
                }
            });

            // MODIFICADO: Lógica de cálculo con ordenamiento geográfico
            function calculateIntermediateTimes(recorridoName) {
                const points = recorridos[recorridoName];
                if (!points || points.length < 2) return;
                const firstPoint = points[0];
                const lastPoint = points[points.length - 1];
                if (!firstPoint.dateTime || !lastPoint.dateTime) return;

                const startTime = new Date(firstPoint.dateTime).getTime();
                const endTime = new Date(lastPoint.dateTime).getTime();
                const totalDurationMs = endTime - startTime;
                if (totalDurationMs <= 0) return;

                let intermediatePoints = points.slice(1, -1);
                const startLatLng = L.latLng(firstPoint.lat, firstPoint.lng);
                intermediatePoints.sort((a, b) => startLatLng.distanceTo(L.latLng(a.lat, a.lng)) - startLatLng.distanceTo(L.latLng(b.lat, b.lng)));
                
                const sortedPoints = [firstPoint, ...intermediatePoints, lastPoint];
                recorridos[recorridoName] = sortedPoints;

                let totalDistance = 0;
                for (let i = 0; i < sortedPoints.length - 1; i++) {
                    const from = L.latLng(sortedPoints[i].lat, sortedPoints[i].lng);
                    const to = L.latLng(sortedPoints[i+1].lat, sortedPoints[i+1].lng);
                    sortedPoints[i].distanceToNext = from.distanceTo(to);
                    totalDistance += sortedPoints[i].distanceToNext;
                }
                if (totalDistance === 0) return;

                let cumulativeDistance = 0;
                for (let i = 1; i < sortedPoints.length - 1; i++) {
                    cumulativeDistance += sortedPoints[i-1].distanceToNext;
                    const progress = cumulativeDistance / totalDistance;
                    const pointTimeMs = startTime + (totalDurationMs * progress);
                    sortedPoints[i].dateTime = new Date(pointTimeMs).toISOString().slice(0, 19);
                }
                saveRecorridosToStorage();
            }

            // --- LÓGICA DE SEGUIMIENTO EN TIEMPO REAL ---
            startBtn.addEventListener('click', () => {
                const selectedRecorrido = recorridoSelect.value;
                if (!selectedRecorrido || recorridos[selectedRecorrido].length < 2) {
                    alert("Selecciona un recorrido con al menos 2 puntos para iniciar.");
                    return;
                }
                currentRecorrido = { name: selectedRecorrido, stops: recorridos[selectedRecorrido], lastVisitedStopIndex: -1, currentTargetIndex: 0 };
                startBtn.disabled = true; stopBtn.disabled = false; recorridoSelect.disabled = true; createRecorridoBtn.disabled = true; deleteRecorridoBtn.disabled = true; radiusInput.disabled = true; autoCalcCheckbox.disabled = true;
                
                etaContainer.classList.remove('hidden');

                if (navigator.geolocation) {
                    gpsInterval = navigator.geolocation.watchPosition(updateDriverPosition, handleLocationError, { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 });
                } else {
                    alert("Geolocalización no es soportada.");
                    stopTracking();
                }
                timeUpdateInterval = setInterval(updateTimeDisplay, 1000);
            });
            
            stopBtn.addEventListener('click', stopTracking);

            function stopTracking() {
                if (gpsInterval) navigator.geolocation.clearWatch(gpsInterval);
                if (timeUpdateInterval) clearInterval(timeUpdateInterval);
                currentRecorrido = null; gpsInterval = null; timeUpdateInterval = null; currentDriverLatLng = null;
                startBtn.disabled = false; stopBtn.disabled = true; recorridoSelect.disabled = false; createRecorridoBtn.disabled = false; deleteRecorridoBtn.disabled = false; radiusInput.disabled = false; autoCalcCheckbox.disabled = false;
                updateStatus('--:--', 'inactive');
                nextStopInfo.textContent = '';
                currentStopInfo.classList.add('hidden');
                currentStopInfo.textContent = '';
                etaContainer.classList.add('hidden');
            }

            function updateDriverPosition(position) {
                currentDriverLatLng = L.latLng(position.coords.latitude, position.coords.longitude);
                driverMarker.setLatLng(currentDriverLatLng);
                if (currentRecorrido) checkRecorridoStatus(currentDriverLatLng);
            }

            function checkRecorridoStatus(driverLatLng) {
                if (!currentRecorrido) return;

                let inRadiusOfAnyStop = null;
                for (let i = 0; i < currentRecorrido.stops.length; i++) {
                    const stop = currentRecorrido.stops[i];
                    if (stop.type === 'stop' && driverLatLng.distanceTo(L.latLng(stop.lat, stop.lng)) <= stopRadius) {
                        inRadiusOfAnyStop = { stop: stop, index: i };
                        break;
                    }
                }

                if (inRadiusOfAnyStop) {
                    currentStopInfo.textContent = `PARADA ACTUAL: ${inRadiusOfAnyStop.stop.name || `Parada ${inRadiusOfAnyStop.index + 1}`}`;
                    currentStopInfo.classList.remove('hidden');
                    if (inRadiusOfAnyStop.index > currentRecorrido.lastVisitedStopIndex) {
                        currentRecorrido.lastVisitedStopIndex = inRadiusOfAnyStop.index;
                    }
                } else {
                    currentStopInfo.classList.add('hidden');
                }

                let closestPointIndex = -1;
                let minDistance = Infinity;
                for (let i = currentRecorrido.lastVisitedStopIndex + 1; i < currentRecorrido.stops.length; i++) {
                    const distance = driverLatLng.distanceTo(L.latLng(currentRecorrido.stops[i].lat, currentRecorrido.stops[i].lng));
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestPointIndex = i;
                    }
                }
                
                if (closestPointIndex === -1) {
                    nextStopInfo.textContent = 'Recorrido Finalizado.';
                    updateStatus('FIN', 'ontime');
                    stopTracking();
                    return;
                }
                currentRecorrido.currentTargetIndex = closestPointIndex;

                let nextDisplayStopIndex = currentRecorrido.lastVisitedStopIndex + 1;
                while(nextDisplayStopIndex < currentRecorrido.stops.length && currentRecorrido.stops[nextDisplayStopIndex].type !== 'stop') {
                    nextDisplayStopIndex++;
                }

                if (nextDisplayStopIndex < currentRecorrido.stops.length) {
                    const nextDisplayStop = currentRecorrido.stops[nextDisplayStopIndex];
                    nextStopInfo.textContent = `PRÓXIMA PARADA: ${nextDisplayStop.name || `Parada ${nextDisplayStopIndex + 1}`}`;
                } else {
                    nextStopInfo.textContent = 'Última parada como objetivo.';
                }
            }
            
            function updateTimeDisplay() {
                if (!currentRecorrido || !currentDriverLatLng || currentRecorrido.currentTargetIndex === -1) return;
                
                const targetPoint = currentRecorrido.stops[currentRecorrido.currentTargetIndex];
                const prevIndex = currentRecorrido.lastVisitedStopIndex;

                if (prevIndex < 0) {
                    if (!targetPoint.dateTime) return;
                    const scheduledTimeMs = new Date(targetPoint.dateTime).getTime();
                    const deviationMs = new Date().getTime() - scheduledTimeMs;
                    formatAndDisplayDeviation(deviationMs);
                    updateEtaTable();
                    return;
                }

                const previousPoint = currentRecorrido.stops[prevIndex];
                if (!previousPoint.dateTime || !targetPoint.dateTime) return;

                const prevPointLatLng = L.latLng(previousPoint.lat, previousPoint.lng);
                const targetPointLatLng = L.latLng(targetPoint.lat, targetPoint.lng);
                const totalSegmentDistance = prevPointLatLng.distanceTo(targetPointLatLng);
                const distanceFromPrevPoint = currentDriverLatLng.distanceTo(prevPointLatLng);
                let progress = totalSegmentDistance > 0 ? distanceFromPrevPoint / totalSegmentDistance : 0;
                progress = Math.max(0, Math.min(1, progress));
                const prevScheduledTimeMs = new Date(previousPoint.dateTime).getTime();
                const nextScheduledTimeMs = new Date(targetPoint.dateTime).getTime();
                const totalSegmentTimeMs = nextScheduledTimeMs - prevScheduledTimeMs;
                const expectedTimeAtPositionMs = prevScheduledTimeMs + (totalSegmentTimeMs * progress);
                const deviationMs = new Date().getTime() - expectedTimeAtPositionMs;
                formatAndDisplayDeviation(deviationMs);
                updateEtaTable();
            }
            
            function formatAndDisplayDeviation(deviationMs) {
                lastDeviationSeconds = Math.round(deviationMs / 1000);
                const absDiffSeconds = Math.abs(lastDeviationSeconds);
                const displayMinutes = String(Math.floor(absDiffSeconds / 60)).padStart(2, '0');
                const displaySeconds = String(absDiffSeconds % 60).padStart(2, '0');
                
                const text = lastDeviationSeconds >= 0 ? `-${displayMinutes}:${displaySeconds}` : `+${displayMinutes}:${displaySeconds}`;
                
                let statusClass;
                if (lastDeviationSeconds > 30) statusClass = 'late';
                else if (lastDeviationSeconds < -30) statusClass = 'early';
                else statusClass = 'ontime';
                
                statusIndicator.textContent = text;
                statusIndicator.className = `status-indicator status-${statusClass}`;
            }

            function updateEtaTable() {
                if (!currentRecorrido) return;
                etaTableBody.innerHTML = '';
                const now = new Date();
                
                const hasLeftFirstStop = currentRecorrido.lastVisitedStopIndex >= 0;

                for (let i = currentRecorrido.lastVisitedStopIndex + 1; i < currentRecorrido.stops.length; i++) {
                    const stop = currentRecorrido.stops[i];
                    if (stop.type === 'stop' && stop.dateTime) {
                        const scheduledTime = new Date(stop.dateTime);
                        const etaBaseSeconds = (scheduledTime - now) / 1000;
                        
                        let finalEtaSeconds;
                        if (lastDeviationSeconds > 0) {
                            finalEtaSeconds = etaBaseSeconds - lastDeviationSeconds;
                        } else {
                            if (hasLeftFirstStop) {
                                finalEtaSeconds = etaBaseSeconds - lastDeviationSeconds;
                            } else {
                                finalEtaSeconds = etaBaseSeconds + Math.abs(lastDeviationSeconds);
                            }
                        }

                        let displayEta;
                        if (finalEtaSeconds < 0) displayEta = "YA PASÓ";
                        else if (finalEtaSeconds <= 59) displayEta = "ARRIBANDO";
                        else displayEta = `${Math.floor(finalEtaSeconds / 60)} min.`;
                        
                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td class="px-4 py-3 whitespace-nowrap">${stop.name || `Parada ${i + 1}`}</td>
                            <td class="px-4 py-3 whitespace-nowrap">${formatDateTime(stop.dateTime)}</td>
                            <td class="px-4 py-3 whitespace-nowrap font-bold">${displayEta}</td>
                        `;
                        etaTableBody.appendChild(row);
                    }
                }
            }

            function handleLocationError(error) {
                console.error("Error de Geolocalización: ", error);
                alert(`Error al obtener la ubicación: ${error.message}`);
                stopTracking();
            }

            // --- FUNCIONES DEL MAPA ---
            let recorridoPolyline = null;
            let stopMarkers = [];

            function clearMapLayers() {
                if (recorridoPolyline) map.removeLayer(recorridoPolyline);
                stopMarkers.forEach(marker => map.removeLayer(marker));
                radiusCircles.forEach(circle => map.removeLayer(circle));
                recorridoPolyline = null; stopMarkers = []; radiusCircles = [];
            }

            function drawRecorridoOnMap(recorridoName) {
                clearMapLayers();
                const stops = recorridos[recorridoName];
                if (!stops || stops.length < 1) return;
                const latLngs = stops.map(stop => [stop.lat, stop.lng]);
                recorridoPolyline = L.polyline(latLngs, { color: 'blue' }).addTo(map);
                stops.forEach((stop, index) => {
                    let marker;
                    const name = stop.name || (stop.type === 'stop' ? `Parada ${index + 1}` : `Punto ${index + 1}`);
                    if (stop.type === 'stop') {
                        marker = L.marker([stop.lat, stop.lng]).addTo(map).bindPopup(`<b>Parada: ${name}</b><br>Hora: ${formatDateTime(stop.dateTime)}`);
                        const circle = L.circle([stop.lat, stop.lng], { radius: stopRadius, color: '#16a34a', fillColor: '#22c55e', fillOpacity: 0.2, weight: 1 }).addTo(map);
                        radiusCircles.push(circle);
                    } else { // waypoint
                        marker = L.circleMarker([stop.lat, stop.lng], { radius: 5, color: 'gray', fillColor: '#6b7280', fillOpacity: 1 }).addTo(map).bindPopup(`<b>Punto de Paso: ${name}</b><br>Hora: ${formatDateTime(stop.dateTime)}`);
                    }
                    stopMarkers.push(marker);
                });
                if(stops.length > 0) map.fitBounds(recorridoPolyline.getBounds());
            }

            // --- INICIO DE LA APLICACIÓN ---
            initializeMap();
            loadRecorridosFromStorage();
        });
    </script>

</body>
</html>
