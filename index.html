<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Move Pro - Asistente de Conductor</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <style>
        #map { height: 400px; width: 100%; }
        .status-indicator {
            font-size: 2.5rem;
            font-weight: bold;
            text-align: center;
            padding: 20px;
            border-radius: 10px;
            color: white;
            transition: background-color 0.3s ease;
        }
        .status-ontime { background-color: #22c55e; } /* green-500 */
        .status-late { background-color: #ef4444; } /* red-500 */
        .status-early { background-color: #3b82f6; } /* blue-500 */
        .status-inactive { background-color: #6b7280; } /* gray-500 */
    </style>
</head>
<body class="bg-gray-100 font-sans">

    <div class="container mx-auto p-4 max-w-4xl">

        <header class="bg-white shadow-md rounded-lg p-4 mb-6">
            <h1 class="text-3xl font-bold text-gray-800">Smart Move Pro</h1>
            <p class="text-gray-600">Tu asistente de ruta en tiempo real.</p>
        </header>

        <main class="grid grid-cols-1 md:grid-cols-3 gap-6">

            <!-- Columna de Gestión de Ruta -->
            <div class="md:col-span-1 bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Gestión de Ruta</h2>
                <div class="mb-4">
                    <label for="route-select" class="block text-sm font-medium text-gray-700 mb-1">Seleccionar Ruta:</label>
                    <select id="route-select" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"></select>
                </div>
                <div class="flex space-x-2 mb-4">
                    <button id="start-route-btn" class="flex-1 bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-md transition">Iniciar</button>
                    <button id="stop-route-btn" class="flex-1 bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-md transition" disabled>Detener</button>
                </div>
                <hr class="my-4">
                <div class="mb-4">
                    <label for="new-route-name" class="block text-sm font-medium text-gray-700 mb-1">Nombre Nueva Ruta:</label>
                    <input type="text" id="new-route-name" placeholder="Ej: Línea 106 - Ramal A" class="w-full p-2 border border-gray-300 rounded-md shadow-sm">
                    <button id="create-route-btn" class="mt-2 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md transition">Crear Ruta</button>
                </div>
                <div>
                    <h3 class="text-lg font-semibold mb-2">Paradas de la Ruta Activa</h3>
                    <ul id="stops-list" class="list-decimal list-inside bg-gray-50 p-3 rounded-md h-48 overflow-y-auto"></ul>
                </div>
            </div>

            <!-- Columna de Mapa y Estado -->
            <div class="md:col-span-2 bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Estado y Mapa</h2>
                <div id="status-indicator" class="status-indicator status-inactive mb-2">--:--</div>
                <p id="next-stop-info" class="text-center text-gray-700 font-semibold h-6 mb-3"></p>
                <div id="map" class="rounded-lg border border-gray-300"></div>
                <p class="text-xs text-gray-500 mt-1 text-center">Haz clic en el mapa para agregar una parada a la ruta activa.</p>
            </div>
        </main>
    </div>

    <!-- Modal para agregar parada -->
    <div id="add-stop-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full hidden">
        <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
            <div class="mt-3 text-center">
                <h3 class="text-lg leading-6 font-medium text-gray-900">Agregar Nueva Parada</h3>
                <div class="mt-2 px-7 py-3">
                    <input type="text" id="stop-name" placeholder="Nombre de la parada" class="w-full p-2 border border-gray-300 rounded-md mb-3">
                    <label for="stop-time" class="text-sm text-gray-600">Hora programada:</label>
                    <input type="time" id="stop-time" class="w-full p-2 border border-gray-300 rounded-md">
                </div>
                <div class="items-center px-4 py-3">
                    <button id="save-stop-btn" class="px-4 py-2 bg-green-500 text-white text-base font-medium rounded-md w-full shadow-sm hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-300">Guardar Parada</button>
                    <button id="cancel-stop-btn" class="mt-2 px-4 py-2 bg-gray-500 text-white text-base font-medium rounded-md w-full shadow-sm hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-300">Cancelar</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- VARIABLES GLOBALES ---
            let map, driverMarker, currentRoute, gpsInterval, timeUpdateInterval, tempStopCoords;
            let routes = {};
            let currentDriverLatLng = null; // NUEVO: Almacena la última posición GPS
            const PROXIMITY_THRESHOLD_METERS = 50;

            // --- ELEMENTOS DEL DOM ---
            const routeSelect = document.getElementById('route-select');
            const startBtn = document.getElementById('start-route-btn');
            const stopBtn = document.getElementById('stop-route-btn');
            const createRouteBtn = document.getElementById('create-route-btn');
            const newRouteNameInput = document.getElementById('new-route-name');
            const stopsList = document.getElementById('stops-list');
            const statusIndicator = document.getElementById('status-indicator');
            const mapElement = document.getElementById('map');
            const nextStopInfo = document.getElementById('next-stop-info');
            const addStopModal = document.getElementById('add-stop-modal');
            const saveStopBtn = document.getElementById('save-stop-btn');
            const cancelStopBtn = document.getElementById('cancel-stop-btn');
            const stopNameInput = document.getElementById('stop-name');
            const stopTimeInput = document.getElementById('stop-time');

            // --- INICIALIZACIÓN ---
            function initializeMap() {
                map = L.map(mapElement).setView([-27.46, -58.83], 13);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(map);
                const driverIcon = L.icon({
                    iconUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon-2x.png',
                    iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
                });
                driverMarker = L.marker([0, 0], { icon: driverIcon }).addTo(map).bindPopup("Tu posición");
                map.on('click', onMapClick);
            }

            function loadRoutesFromStorage() {
                const storedRoutes = localStorage.getItem('busRoutes');
                if (storedRoutes) routes = JSON.parse(storedRoutes);
                updateRouteSelector();
            }

            function saveRoutesToStorage() {
                localStorage.setItem('busRoutes', JSON.stringify(routes));
            }

            // --- GESTIÓN DE RUTAS Y PARADAS ---
            function updateRouteSelector() {
                routeSelect.innerHTML = '<option value="">-- Selecciona una ruta --</option>';
                for (const routeName in routes) {
                    const option = document.createElement('option');
                    option.value = routeName;
                    option.textContent = routeName;
                    routeSelect.appendChild(option);
                }
            }
            
            function updateStopsList(routeName) {
                stopsList.innerHTML = '';
                const stops = routes[routeName] || [];
                if (stops.length === 0) {
                    stopsList.innerHTML = '<li class="text-gray-500">No hay paradas.</li>';
                } else {
                    stops.forEach(stop => {
                        const li = document.createElement('li');
                        li.textContent = `${stop.name} - ${stop.time}`;
                        stopsList.appendChild(li);
                    });
                }
            }

            createRouteBtn.addEventListener('click', () => {
                const routeName = newRouteNameInput.value.trim();
                if (routeName && !routes[routeName]) {
                    routes[routeName] = [];
                    saveRoutesToStorage();
                    updateRouteSelector();
                    newRouteNameInput.value = '';
                    routeSelect.value = routeName;
                    updateStopsList(routeName);
                } else {
                    alert(routes[routeName] ? 'Error: Ya existe una ruta con ese nombre.' : 'Error: Ingresa un nombre válido.');
                }
            });

            routeSelect.addEventListener('change', () => {
                const selectedRoute = routeSelect.value;
                updateStopsList(selectedRoute);
                drawRouteOnMap(selectedRoute);
            });

            function onMapClick(e) {
                if (!routeSelect.value) {
                    alert("Por favor, selecciona o crea una ruta antes de añadir paradas.");
                    return;
                }
                tempStopCoords = e.latlng;
                stopNameInput.value = '';
                stopTimeInput.value = '';
                addStopModal.classList.remove('hidden');
            }

            saveStopBtn.addEventListener('click', () => {
                const stopName = stopNameInput.value.trim();
                const stopTime = stopTimeInput.value;
                const selectedRoute = routeSelect.value;
                if (stopName && stopTime && tempStopCoords && selectedRoute) {
                    const newStop = { name: stopName, time: stopTime, lat: tempStopCoords.lat, lng: tempStopCoords.lng };
                    routes[selectedRoute].push(newStop);
                    routes[selectedRoute].sort((a, b) => a.time.localeCompare(b.time));
                    saveRoutesToStorage();
                    updateStopsList(selectedRoute);
                    drawRouteOnMap(selectedRoute);
                    addStopModal.classList.add('hidden');
                    tempStopCoords = null;
                } else {
                    alert("Por favor, completa todos los campos.");
                }
            });

            cancelStopBtn.addEventListener('click', () => {
                addStopModal.classList.add('hidden');
                tempStopCoords = null;
            });

            // --- LÓGICA DE SEGUIMIENTO EN TIEMPO REAL ---
            startBtn.addEventListener('click', () => {
                const selectedRoute = routeSelect.value;
                if (!selectedRoute || routes[selectedRoute].length < 2) {
                    alert("Selecciona una ruta con al menos 2 paradas para iniciar.");
                    return;
                }
                
                currentRoute = { name: selectedRoute, stops: routes[selectedRoute], nextStopIndex: 0 };
                startBtn.disabled = true;
                stopBtn.disabled = false;
                routeSelect.disabled = true;
                createRouteBtn.disabled = true;
                
                // Avanzar al primer segmento si es necesario
                checkRouteStatus(null, true);

                if (navigator.geolocation) {
                    gpsInterval = navigator.geolocation.watchPosition(
                        updateDriverPosition, handleLocationError, 
                        { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
                    );
                } else {
                    alert("Geolocalización no es soportada.");
                    stopTracking();
                }
                
                timeUpdateInterval = setInterval(updateTimeDisplay, 1000);
            });
            
            stopBtn.addEventListener('click', stopTracking);

            function stopTracking() {
                if (gpsInterval) navigator.geolocation.clearWatch(gpsInterval);
                if (timeUpdateInterval) clearInterval(timeUpdateInterval);
                currentRoute = null;
                gpsInterval = null;
                timeUpdateInterval = null;
                currentDriverLatLng = null;
                startBtn.disabled = false;
                stopBtn.disabled = true;
                routeSelect.disabled = false;
                createRouteBtn.disabled = false;
                updateStatus('--:--', 'inactive');
                nextStopInfo.textContent = '';
            }

            function updateDriverPosition(position) {
                const { latitude, longitude } = position.coords;
                currentDriverLatLng = L.latLng(latitude, longitude); // Actualizar posición global
                driverMarker.setLatLng(currentDriverLatLng);
                map.panTo(currentDriverLatLng);
                if (currentRoute) checkRouteStatus(currentDriverLatLng);
            }

            function checkRouteStatus(driverLatLng, isInitialCheck = false) {
                if (!currentRoute || currentRoute.nextStopIndex >= currentRoute.stops.length) return;
                
                // En la comprobación inicial, solo configuramos la próxima parada
                if(isInitialCheck) {
                    currentRoute.nextStopIndex = 1; // Empezamos apuntando a la segunda parada
                    nextStopInfo.textContent = `Próxima parada: ${currentRoute.stops[1].name}`;
                    return;
                }

                const nextStop = currentRoute.stops[currentRoute.nextStopIndex];
                const distanceToNextStop = driverLatLng.distanceTo(L.latLng(nextStop.lat, nextStop.lng));

                if (distanceToNextStop <= PROXIMITY_THRESHOLD_METERS) {
                    currentRoute.nextStopIndex++;
                    if (currentRoute.nextStopIndex < currentRoute.stops.length) {
                        const newNextStopName = currentRoute.stops[currentRoute.nextStopIndex].name;
                        nextStopInfo.textContent = `Próxima parada: ${newNextStopName}`;
                    } else {
                        nextStopInfo.textContent = 'Ruta Finalizada.';
                        updateStatus('FIN', 'ontime');
                        stopTracking();
                    }
                }
            }

            // MODIFICADO: Lógica de cálculo proporcional
            function updateTimeDisplay() {
                if (!currentRoute || !currentDriverLatLng || currentRoute.nextStopIndex >= currentRoute.stops.length) {
                    return;
                }

                const nextStopIndex = currentRoute.nextStopIndex;
                const previousStop = currentRoute.stops[nextStopIndex - 1];
                const nextStop = currentRoute.stops[nextStopIndex];
                
                // 1. Coordenadas
                const prevStopLatLng = L.latLng(previousStop.lat, previousStop.lng);
                const nextStopLatLng = L.latLng(nextStop.lat, nextStop.lng);

                // 2. Distancias
                const totalSegmentDistance = prevStopLatLng.distanceTo(nextStopLatLng);
                const distanceFromPrevStop = currentDriverLatLng.distanceTo(prevStopLatLng);
                
                // 3. Progreso
                let progress = totalSegmentDistance > 1 ? distanceFromPrevStop / totalSegmentDistance : 0;
                progress = Math.max(0, Math.min(1, progress)); // Limitar entre 0 y 1

                // 4. Tiempos en milisegundos
                const today = new Date();
                const dateString = today.toISOString().split('T')[0];
                const prevScheduledTimeMs = new Date(`${dateString}T${previousStop.time}`).getTime();
                const nextScheduledTimeMs = new Date(`${dateString}T${nextStop.time}`).getTime();

                // 5. Tiempo total del segmento
                const totalSegmentTimeMs = nextScheduledTimeMs - prevScheduledTimeMs;

                // 6. Tiempo esperado en la posición actual
                const expectedTimeAtPositionMs = prevScheduledTimeMs + (totalSegmentTimeMs * progress);
                
                // 7. Desvío
                const deviationMs = today.getTime() - expectedTimeAtPositionMs;

                // 8. Formatear y mostrar
                formatAndDisplayDeviation(deviationMs);
            }
            
            function formatAndDisplayDeviation(deviationMs) {
                const diffSeconds = Math.round(deviationMs / 1000);
                const absDiffSeconds = Math.abs(diffSeconds);
                const displayMinutes = String(Math.floor(absDiffSeconds / 60)).padStart(2, '0');
                const displaySeconds = String(absDiffSeconds % 60).padStart(2, '0');

                let text, statusClass;

                if (diffSeconds > 30) { // Atrasado (con margen)
                    text = `-${displayMinutes}:${displaySeconds}`;
                    statusClass = 'late';
                } else if (diffSeconds < -30) { // Adelantado (con margen)
                    text = `+${displayMinutes}:${displaySeconds}`;
                    statusClass = 'early';
                } else { // A tiempo
                    text = '00:00';
                    statusClass = 'ontime';
                }

                statusIndicator.textContent = text;
                statusIndicator.className = `status-indicator status-${statusClass}`;
            }

            function handleLocationError(error) {
                console.error("Error de Geolocalización: ", error);
                alert(`Error al obtener la ubicación: ${error.message}`);
                stopTracking();
            }

            // --- FUNCIONES DEL MAPA ---
            let routePolyline = null;
            let stopMarkers = [];

            function clearMapLayers() {
                if (routePolyline) map.removeLayer(routePolyline);
                stopMarkers.forEach(marker => map.removeLayer(marker));
                routePolyline = null;
                stopMarkers = [];
            }

            function drawRouteOnMap(routeName) {
                clearMapLayers();
                const stops = routes[routeName];
                if (!stops || stops.length < 1) return;

                const latLngs = stops.map(stop => [stop.lat, stop.lng]);
                routePolyline = L.polyline(latLngs, { color: 'blue' }).addTo(map);
                
                stops.forEach((stop, index) => {
                    const marker = L.marker([stop.lat, stop.lng])
                        .addTo(map)
                        .bindPopup(`<b>${index + 1}. ${stop.name}</b><br>Hora: ${stop.time}`);
                    stopMarkers.push(marker);
                });

                if(stops.length > 0) map.fitBounds(routePolyline.getBounds());
            }

            // --- INICIO DE LA APLICACIÓN ---
            initializeMap();
            loadRoutesFromStorage();
        });
    </script>

</body>
</html>
