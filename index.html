<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Smart Move Pro - Seguimiento de Rutas Profesional</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* --- VARIABLES CSS --- */
        :root {
            /* Colores principales - FONDO NEGRO */
            --bg-primary: #000000;
            --bg-secondary: #111111;
            --bg-surface: #1a1a1a;
            --bg-card: #222222;
            
            /* Colores de texto */
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
            --text-muted: #888888;
            
            /* Colores de acento */
            --accent-primary: #3b82f6;
            --accent-secondary: #10b981;
            --accent-warning: #f59e0b;
            --accent-danger: #ef4444;
            
            /* Colores de estado */
            --success: #16a34a;
            --warning: #f59e0b;
            --error: #dc2626;
            --info: #2563eb;
            
            /* Colores de desvío horario (más opacos y fuertes) */
            --deviation-green: #16a34a;    /* -02:59 a +02:59 */
            --deviation-blue: #2563eb;     /* -03:00 o más atraso */
            --deviation-red: #dc2626;      /* +03:00 o más adelanto */
            
            /* Bordes */
            --border-color: #333333;
            --border-light: #444444;
            
            /* Espaciado */
            --spacing-xs: 0.25rem;
            --spacing-sm: 0.5rem;
            --spacing-md: 0.75rem;
            --spacing-lg: 1rem;
            --spacing-xl: 1.25rem;
            --spacing-2xl: 1.5rem;
            
            /* Bordes redondeados */
            --radius-sm: 0.25rem;
            --radius-md: 0.375rem;
            --radius-lg: 0.5rem;
            --radius-xl: 0.75rem;
            
            /* Sombras */
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.3);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.4), 0 2px 4px -2px rgb(0 0 0 / 0.3);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.5), 0 4px 6px -4px rgb(0 0 0 / 0.4);
            
            /* Transiciones */
            --transition-fast: 150ms ease-in-out;
            --transition-normal: 250ms ease-in-out;
            --transition-slow: 350ms ease-in-out;
        }

        /* --- ESTILOS GENERALES Y LAYOUT MÓVIL --- */
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100vh;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            font-size: 14px;
            line-height: 1.4;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* --- MAPA OPTIMIZADO PARA MÓVIL --- */
        #map {
            height: 50vh;
            width: 100%;
            border: none;
            position: relative;
            z-index: 1;
        }

        /* Asegurar que el mapa tenga colores */
        .leaflet-container {
            background: #f8f9fa !important;
        }

        /* --- CONTROLES OPTIMIZADOS PARA MÓVIL --- */
        #controls {
            height: 50vh;
            overflow-y: auto;
            overflow-x: hidden;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            scrollbar-width: thin;
            scrollbar-color: var(--border-color) transparent;
            -webkit-overflow-scrolling: touch;
        }

        #controls::-webkit-scrollbar {
            width: 4px;
        }

        #controls::-webkit-scrollbar-track {
            background: transparent;
        }

        #controls::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: var(--radius-sm);
        }

        /* --- SECCIONES COLAPSABLES MÓVIL --- */
        .accordion-header {
            background: var(--bg-secondary);
            padding: var(--spacing-lg);
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
            font-size: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all var(--transition-normal);
            min-height: 48px;
            touch-action: manipulation;
        }

        .accordion-header:active {
            background: var(--bg-surface);
        }

        .accordion-header .icon {
            font-size: 18px;
            transition: transform var(--transition-normal);
        }

        .accordion-header.collapsed .icon {
            transform: rotate(180deg);
        }

        .accordion-content {
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border-color);
            overflow: hidden;
            transition: max-height var(--transition-normal);
        }

        .accordion-content.collapsed {
            max-height: 0;
        }

        .accordion-content.expanded {
            max-height: 1000px;
        }

        .accordion-body {
            padding: var(--spacing-lg);
        }

        /* --- CONTROLES DE RADIO MÓVIL --- */
        .radio-control {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
        }

        .radio-control label {
            display: block;
            font-weight: 600;
            margin-bottom: var(--spacing-sm);
            color: var(--text-primary);
            font-size: 14px;
        }

        .radio-input-group {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .radio-input-group input {
            flex: 1;
            padding: var(--spacing-md);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            background: var(--bg-surface);
            color: var(--text-primary);
            font-size: 16px;
            min-height: 44px;
        }

        .radio-input-group input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .radio-input-group span {
            color: var(--text-secondary);
            font-size: 14px;
            white-space: nowrap;
        }

        .radio-help {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: var(--spacing-sm);
        }

        /* --- BOTONES OPTIMIZADOS PARA MÓVIL --- */
        .btn-group {
            display: flex;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-lg);
            flex-wrap: wrap;
        }

        .btn {
            flex: 1;
            min-height: 44px;
            padding: var(--spacing-md) var(--spacing-lg);
            border: none;
            border-radius: var(--radius-lg);
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all var(--transition-normal);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--spacing-sm);
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }

        .btn:active {
            transform: scale(0.98);
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-primary), #1d4ed8);
            color: white;
        }

        .btn-secondary {
            background: var(--bg-surface);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--accent-danger), #b91c1c);
            color: white;
        }

        /* --- LISTA DE PUNTOS MÓVIL --- */
        .route-list {
            background: var(--bg-primary);
        }

        .route-item {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            margin-bottom: var(--spacing-md);
            padding: var(--spacing-lg);
            position: relative;
        }

        .route-item-header {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        .route-item-icon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            color: white;
        }

        .route-item-icon.start { background: var(--success); }
        .route-item-icon.stop { background: var(--accent-primary); }
        .route-item-icon.waypoint { background: var(--accent-warning); }
        .route-item-icon.end { background: var(--accent-danger); }

        .route-item-title {
            flex: 1;
            font-weight: 600;
            color: var(--text-primary);
        }

        .route-item-actions {
            display: flex;
            gap: var(--spacing-sm);
        }

        .btn-icon {
            width: 36px;
            height: 36px;
            border: none;
            border-radius: var(--radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all var(--transition-fast);
            touch-action: manipulation;
        }

        .btn-icon.edit {
            background: var(--accent-primary);
            color: white;
        }

        .btn-icon.delete {
            background: var(--accent-danger);
            color: white;
        }

        .btn-icon:active {
            transform: scale(0.95);
        }

        /* --- POPUP MÓVIL --- */
        .leaflet-popup-content-wrapper {
            background: var(--bg-card) !important;
            border: 1px solid var(--border-color) !important;
            border-radius: var(--radius-lg) !important;
            box-shadow: var(--shadow-lg) !important;
        }

        .leaflet-popup-content {
            color: var(--text-primary) !important;
            margin: 0 !important;
            padding: var(--spacing-lg) !important;
            min-width: 200px !important;
        }

        .popup-buttons {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
            margin-top: var(--spacing-md);
        }

        .popup-btn {
            padding: var(--spacing-md);
            border: none;
            border-radius: var(--radius-md);
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition-fast);
            min-height: 44px;
            touch-action: manipulation;
        }

        .popup-btn.start {
            background: var(--success);
            color: white;
        }

        .popup-btn.stop {
            background: var(--accent-primary);
            color: white;
        }

        .popup-btn.waypoint {
            background: var(--accent-warning);
            color: white;
        }

        .popup-btn:active {
            transform: scale(0.98);
        }

        /* --- MODAL MÓVIL --- */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            padding: var(--spacing-lg);
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-xl);
            padding: var(--spacing-xl);
            width: 100%;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-lg);
            padding-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--border-color);
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .modal-close {
            width: 32px;
            height: 32px;
            border: none;
            background: var(--bg-surface);
            color: var(--text-secondary);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            touch-action: manipulation;
        }

        .modal-close:active {
            background: var(--border-color);
        }

        /* --- FORMULARIOS MÓVIL --- */
        .form-group {
            margin-bottom: var(--spacing-lg);
        }

        .form-label {
            display: block;
            font-weight: 600;
            margin-bottom: var(--spacing-sm);
            color: var(--text-primary);
            font-size: 14px;
        }

        .form-input {
            width: 100%;
            padding: var(--spacing-md);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            background: var(--bg-surface);
            color: var(--text-primary);
            font-size: 16px;
            min-height: 44px;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        /* --- ESTADO DE SEGUIMIENTO MÓVIL --- */
        .tracking-status {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
        }

        .status-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-md);
        }

        .status-item {
            text-align: center;
        }

        .status-label {
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: var(--spacing-xs);
        }

        .status-value {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .status-value.deviation {
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--radius-md);
            color: white;
        }

        .status-value.deviation.green { background: var(--deviation-green); }
        .status-value.deviation.blue { background: var(--deviation-blue); }
        .status-value.deviation.red { background: var(--deviation-red); }

        /* --- DEBUG PANEL MÓVIL --- */
        .debug-panel {
            background: var(--bg-surface);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            margin-top: var(--spacing-lg);
        }

        .debug-content {
            padding: var(--spacing-lg);
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.4;
            max-height: 200px;
            overflow-y: auto;
        }

        /* --- RESPONSIVE ADICIONAL --- */
        @media (max-width: 480px) {
            body {
                font-size: 13px;
            }
            
            .accordion-header {
                padding: var(--spacing-md);
                font-size: 14px;
            }
            
            .btn {
                font-size: 13px;
                padding: var(--spacing-sm) var(--spacing-md);
            }
            
            .modal-content {
                padding: var(--spacing-lg);
                margin: var(--spacing-md);
            }
        }

        @media (max-width: 360px) {
            .status-grid {
                grid-template-columns: 1fr;
            }
            
            .btn-group {
                flex-direction: column;
            }
        }

        /* --- ANIMACIONES --- */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .fade-in {
            animation: fadeIn 0.3s ease-out;
        }

        /* --- UTILIDADES --- */
        .text-center { text-align: center; }
        .text-small { font-size: 12px; }
        .text-muted { color: var(--text-muted); }
        .mb-0 { margin-bottom: 0; }
        .mt-lg { margin-top: var(--spacing-lg); }
        .hidden { display: none; }
        .flex { display: flex; }
        .flex-1 { flex: 1; }
        .items-center { align-items: center; }
        .justify-between { justify-content: space-between; }
        .gap-sm { gap: var(--spacing-sm); }
    </style>
</head>
<body>
    <!-- Mapa -->
    <div id="map"></div>
    
    <!-- Controles -->
    <div id="controls">
        <!-- Sección de Edición de Ruta -->
        <div class="accordion-section">
            <div class="accordion-header" onclick="toggleAccordion('edit-route')">
                <span>📍 Editar Ruta Actual</span>
                <span class="icon">▲</span>
            </div>
            <div class="accordion-content expanded" id="edit-route-content">
                <div class="accordion-body">
                    <!-- Control de Radio General -->
                    <div class="radio-control">
                        <label for="generalRadius">🎯 Radio General para Todos los Puntos</label>
                        <div class="radio-input-group">
                            <input type="number" id="generalRadius" value="50" min="10" max="500" onchange="updateGeneralRadius()">
                            <span>metros</span>
                        </div>
                        <div class="radio-help">Este radio se aplicará a todos los puntos: inicio, paradas y final.</div>
                    </div>
                    
                    <!-- Botones de Control -->
                    <div class="btn-group">
                        <button class="btn btn-secondary" onclick="toggleWaypoints()">
                            👁️ Ver/Ocultar Ptos. de Paso
                        </button>
                        <button class="btn btn-danger" onclick="clearRoute()">
                            🗑️ Limpiar Ruta
                        </button>
                    </div>
                    
                    <!-- Instrucciones -->
                    <div class="text-small text-muted text-center">
                        Toca una zona vacía del mapa para añadir un punto.<br>
                        Toca un punto existente para editarlo o arrastrarlo para moverlo.
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Lista de Puntos de Ruta -->
        <div class="accordion-section">
            <div class="accordion-header" onclick="toggleAccordion('route-list')">
                <span>📋 Lista de Puntos de Ruta</span>
                <span class="icon">▲</span>
            </div>
            <div class="accordion-content expanded" id="route-list-content">
                <div class="accordion-body">
                    <div class="form-group">
                        <label class="form-label">
                            <input type="checkbox" id="autoCalculate" checked onchange="toggleAutoCalculate()">
                            Calcular horarios intermedios automáticamente
                        </label>
                    </div>
                    <div id="routePointsList" class="route-list">
                        <!-- Los puntos se añadirán dinámicamente aquí -->
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Estado de Seguimiento -->
        <div class="accordion-section">
            <div class="accordion-header" onclick="toggleAccordion('tracking-status')">
                <span>🚀 Estado de Seguimiento</span>
                <span class="icon">▲</span>
            </div>
            <div class="accordion-content expanded" id="tracking-status-content">
                <div class="accordion-body">
                    <div class="tracking-status">
                        <div class="status-grid">
                            <div class="status-item">
                                <div class="status-label">Hora Actual</div>
                                <div class="status-value" id="currentTime">--:--:--</div>
                            </div>
                            <div class="status-item">
                                <div class="status-label">ETA</div>
                                <div class="status-value" id="etaDisplay">-- min.</div>
                            </div>
                            <div class="status-item">
                                <div class="status-label">Desvío Horario</div>
                                <div class="status-value deviation" id="timeDeviation">00:00</div>
                            </div>
                            <div class="status-item">
                                <div class="status-label">Velocidad</div>
                                <div class="status-value" id="speedDisplay">0 km/h</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Debug Panel -->
                    <div class="debug-panel">
                        <div class="accordion-header" onclick="toggleAccordion('debug-info')">
                            <span>🔧 Debug ETA</span>
                            <span class="icon">▲</span>
                        </div>
                        <div class="accordion-content collapsed" id="debug-info-content">
                            <div class="debug-content" id="debugInfo">
                                Información de debug aparecerá aquí...
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Guardar y Cargar Rutas -->
        <div class="accordion-section">
            <div class="accordion-header" onclick="toggleAccordion('save-load')">
                <span>💾 Guardar y Cargar Rutas</span>
                <span class="icon">▲</span>
            </div>
            <div class="accordion-content collapsed" id="save-load-content">
                <div class="accordion-body">
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="saveRoute()">
                            💾 Guardar Ruta
                        </button>
                        <button class="btn btn-secondary" onclick="loadRoute()">
                            📂 Cargar Ruta
                        </button>
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-secondary" onclick="exportRoute()">
                            📤 Exportar JSON
                        </button>
                        <button class="btn btn-secondary" onclick="importRoute()">
                            📥 Importar JSON
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modal para editar puntos -->
    <div id="editModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="modalTitle">Editar Punto</h3>
                <button class="modal-close" onclick="closeEditModal()">×</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label" for="pointName">Nombre:</label>
                    <input type="text" id="pointName" class="form-input" placeholder="Nombre del punto">
                </div>
                <div class="form-group" id="scheduleGroup">
                    <label class="form-label" id="scheduleLabel">Horario:</label>
                    <input type="datetime-local" id="pointSchedule" class="form-input">
                </div>
                <div class="btn-group">
                    <button class="btn btn-danger" onclick="deleteCurrentPoint()">🗑️ Borrar</button>
                    <button class="btn btn-primary" onclick="saveCurrentPoint()">💾 Guardar</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <script>
        // Variables globales
        let map;
        let routePoints = [];
        let currentLocationMarker = null;
        let routePolyline = null;
        let currentEditingPoint = null;
        let generalRadius = 50;
        let waypointsVisible = true;
        let autoCalculateSchedules = true;
        let watchId = null;
        let lastKnownPosition = null;
        let currentSpeed = 0;

        // Inicialización
        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            startLocationTracking();
            startTimeUpdates();
            
            // Prevenir zoom con gestos en móvil
            document.addEventListener('touchmove', function(e) {
                if (e.scale !== 1) {
                    e.preventDefault();
                }
            }, { passive: false });
        });

        // Inicializar mapa con colores
        function initMap() {
            map = L.map('map', {
                center: [-27.4678, -58.8344], // Corrientes, Argentina
                zoom: 13,
                zoomControl: true,
                attributionControl: true,
                touchZoom: true,
                doubleClickZoom: false,
                scrollWheelZoom: true,
                dragging: true
            });

            // Tile layer con colores (similar a la imagen de referencia)
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);

            // Eventos del mapa
            map.on('click', onMapClick);
            map.on('contextmenu', function(e) {
                e.originalEvent.preventDefault();
            });
        }

        // Manejar clic en el mapa
        function onMapClick(e) {
            const popup = L.popup()
                .setLatLng(e.latlng)
                .setContent(createPopupContent())
                .openOn(map);
            
            popup._latlng = e.latlng;
        }

        // Crear contenido del popup
        function createPopupContent() {
            return `
                <div class="popup-buttons">
                    <button class="popup-btn start" onclick="addPoint('start')">📍 Inicio/Final</button>
                    <button class="popup-btn stop" onclick="addPoint('stop')">🚏 Parada</button>
                    <button class="popup-btn waypoint" onclick="addPoint('waypoint')">📌 Paso</button>
                </div>
            `;
        }

        // Añadir punto
        function addPoint(type) {
            const popup = map._popup;
            if (!popup) return;
            
            const latlng = popup._latlng;
            map.closePopup();
            
            const point = {
                id: Date.now(),
                type: type,
                lat: latlng.lat,
                lng: latlng.lng,
                name: getDefaultName(type),
                schedule: null,
                marker: null,
                circle: null
            };
            
            // Determinar posición en la ruta
            if (type === 'start') {
                // Buscar si ya hay un punto de inicio
                const existingStart = routePoints.find(p => p.type === 'start');
                if (existingStart) {
                    // Convertir el punto de inicio existente en punto final
                    existingStart.type = 'end';
                    existingStart.name = 'Punto Final';
                    updatePointMarker(existingStart);
                }
                routePoints.unshift(point);
            } else if (type === 'end') {
                routePoints.push(point);
            } else {
                // Insertar en posición apropiada
                routePoints.push(point);
            }
            
            createPointMarker(point);
            updateRouteDisplay();
            updateRoutePolyline();
            
            if (autoCalculateSchedules) {
                calculateIntermediateSchedules();
            }
        }

        // Obtener nombre por defecto
        function getDefaultName(type) {
            switch(type) {
                case 'start': return 'Punto de Inicio';
                case 'end': return 'Punto Final';
                case 'stop': return `Parada ${routePoints.filter(p => p.type === 'stop').length + 1}`;
                case 'waypoint': return `Paso ${routePoints.filter(p => p.type === 'waypoint').length + 1}`;
                default: return 'Punto';
            }
        }

        // Crear marcador del punto
        function createPointMarker(point) {
            const icon = getPointIcon(point.type);
            
            point.marker = L.marker([point.lat, point.lng], {
                icon: icon,
                draggable: true
            }).addTo(map);
            
            point.circle = L.circle([point.lat, point.lng], {
                radius: generalRadius,
                color: getPointColor(point.type),
                fillColor: getPointColor(point.type),
                fillOpacity: 0.1,
                weight: 2
            }).addTo(map);
            
            point.marker.on('click', () => editPoint(point));
            point.marker.on('dragend', (e) => {
                const newPos = e.target.getLatLng();
                point.lat = newPos.lat;
                point.lng = newPos.lng;
                point.circle.setLatLng(newPos);
                updateRoutePolyline();
            });
        }

        // Obtener icono del punto
        function getPointIcon(type) {
            const colors = {
                start: '#16a34a',
                end: '#dc2626',
                stop: '#2563eb',
                waypoint: '#f59e0b'
            };
            
            const labels = {
                start: 'PI',
                end: 'PF',
                stop: 'P',
                waypoint: 'PS'
            };
            
            return L.divIcon({
                html: `<div style="background: ${colors[type]}; color: white; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">${labels[type]}</div>`,
                className: 'custom-marker',
                iconSize: [30, 30],
                iconAnchor: [15, 15]
            });
        }

        // Obtener color del punto
        function getPointColor(type) {
            const colors = {
                start: '#16a34a',
                end: '#dc2626',
                stop: '#2563eb',
                waypoint: '#f59e0b'
            };
            return colors[type] || '#6b7280';
        }

        // Actualizar marcador del punto
        function updatePointMarker(point) {
            if (point.marker) {
                point.marker.setIcon(getPointIcon(point.type));
                point.circle.setStyle({
                    color: getPointColor(point.type),
                    fillColor: getPointColor(point.type)
                });
            }
        }

        // Editar punto
        function editPoint(point) {
            currentEditingPoint = point;
            
            document.getElementById('modalTitle').textContent = 
                point.type === 'start' ? 'Punto de Inicio' :
                point.type === 'end' ? 'Punto Final' :
                point.type === 'stop' ? 'Parada' : 'Punto de Paso';
            
            document.getElementById('pointName').value = point.name || '';
            
            const scheduleGroup = document.getElementById('scheduleGroup');
            const scheduleLabel = document.getElementById('scheduleLabel');
            
            if (point.type === 'start') {
                scheduleLabel.textContent = 'Salida Programada:';
                scheduleGroup.style.display = 'block';
            } else if (point.type === 'end') {
                scheduleLabel.textContent = 'Llegada Programada:';
                scheduleGroup.style.display = 'block';
            } else if (point.type === 'stop') {
                scheduleLabel.textContent = 'Horario de Parada:';
                scheduleGroup.style.display = 'block';
            } else {
                scheduleGroup.style.display = 'none';
            }
            
            if (point.schedule) {
                document.getElementById('pointSchedule').value = point.schedule;
            }
            
            document.getElementById('editModal').classList.add('show');
        }

        // Cerrar modal de edición
        function closeEditModal() {
            document.getElementById('editModal').classList.remove('show');
            currentEditingPoint = null;
        }

        // Guardar punto actual
        function saveCurrentPoint() {
            if (!currentEditingPoint) return;
            
            currentEditingPoint.name = document.getElementById('pointName').value || currentEditingPoint.name;
            currentEditingPoint.schedule = document.getElementById('pointSchedule').value || null;
            
            updateRouteDisplay();
            closeEditModal();
        }

        // Borrar punto actual
        function deleteCurrentPoint() {
            if (!currentEditingPoint) return;
            
            // Remover del mapa
            if (currentEditingPoint.marker) {
                map.removeLayer(currentEditingPoint.marker);
            }
            if (currentEditingPoint.circle) {
                map.removeLayer(currentEditingPoint.circle);
            }
            
            // Remover del array
            routePoints = routePoints.filter(p => p.id !== currentEditingPoint.id);
            
            updateRouteDisplay();
            updateRoutePolyline();
            closeEditModal();
        }

        // Actualizar radio general
        function updateGeneralRadius() {
            generalRadius = parseInt(document.getElementById('generalRadius').value) || 50;
            
            routePoints.forEach(point => {
                if (point.circle) {
                    point.circle.setRadius(generalRadius);
                }
            });
        }

        // Alternar visibilidad de puntos de paso
        function toggleWaypoints() {
            waypointsVisible = !waypointsVisible;
            
            routePoints.forEach(point => {
                if (point.type === 'waypoint') {
                    if (waypointsVisible) {
                        if (point.marker) map.addLayer(point.marker);
                        if (point.circle) map.addLayer(point.circle);
                    } else {
                        if (point.marker) map.removeLayer(point.marker);
                        if (point.circle) map.removeLayer(point.circle);
                    }
                }
            });
        }

        // Limpiar ruta
        function clearRoute() {
            if (confirm('¿Estás seguro de que quieres limpiar toda la ruta?')) {
                routePoints.forEach(point => {
                    if (point.marker) map.removeLayer(point.marker);
                    if (point.circle) map.removeLayer(point.circle);
                });
                
                routePoints = [];
                updateRouteDisplay();
                updateRoutePolyline();
            }
        }

        // Actualizar visualización de la ruta
        function updateRouteDisplay() {
            const container = document.getElementById('routePointsList');
            container.innerHTML = '';
            
            routePoints.forEach((point, index) => {
                const item = document.createElement('div');
                item.className = 'route-item fade-in';
                
                const iconClass = point.type;
                const scheduleText = point.schedule ? 
                    new Date(point.schedule).toLocaleTimeString('es-ES', { 
                        hour: '2-digit', 
                        minute: '2-digit' 
                    }) : 'Sin horario';
                
                item.innerHTML = `
                    <div class="route-item-header">
                        <div class="route-item-icon ${iconClass}">${getPointLabel(point.type)}</div>
                        <div class="route-item-title">${point.name}</div>
                        <div class="route-item-actions">
                            <button class="btn-icon edit" onclick="editPoint(routePoints[${index}])">✏️</button>
                            <button class="btn-icon delete" onclick="deletePointByIndex(${index})">🗑️</button>
                        </div>
                    </div>
                    <div class="text-small text-muted">${scheduleText}</div>
                `;
                
                container.appendChild(item);
            });
        }

        // Obtener etiqueta del punto
        function getPointLabel(type) {
            const labels = {
                start: 'PI',
                end: 'PF',
                stop: 'P',
                waypoint: 'PS'
            };
            return labels[type] || 'P';
        }

        // Borrar punto por índice
        function deletePointByIndex(index) {
            const point = routePoints[index];
            if (point) {
                if (point.marker) map.removeLayer(point.marker);
                if (point.circle) map.removeLayer(point.circle);
                routePoints.splice(index, 1);
                updateRouteDisplay();
                updateRoutePolyline();
            }
        }

        // Actualizar polilínea de la ruta
        function updateRoutePolyline() {
            if (routePolyline) {
                map.removeLayer(routePolyline);
            }
            
            if (routePoints.length > 1) {
                const latlngs = routePoints.map(point => [point.lat, point.lng]);
                routePolyline = L.polyline(latlngs, {
                    color: '#3b82f6',
                    weight: 4,
                    opacity: 0.8,
                    dashArray: '10, 5'
                }).addTo(map);
            }
        }

        // Alternar cálculo automático
        function toggleAutoCalculate() {
            autoCalculateSchedules = document.getElementById('autoCalculate').checked;
            if (autoCalculateSchedules) {
                calculateIntermediateSchedules();
            }
        }

        // Calcular horarios intermedios
        function calculateIntermediateSchedules() {
            const startPoint = routePoints.find(p => p.type === 'start');
            const endPoint = routePoints.find(p => p.type === 'end');
            
            if (!startPoint || !endPoint || !startPoint.schedule || !endPoint.schedule) {
                return;
            }
            
            const startTime = new Date(startPoint.schedule);
            const endTime = new Date(endPoint.schedule);
            const totalDuration = endTime - startTime;
            
            if (totalDuration <= 0) return;
            
            const totalDistance = calculateTotalDistance();
            let accumulatedDistance = 0;
            
            routePoints.forEach((point, index) => {
                if (point.type === 'start' || point.type === 'end') return;
                
                if (index > 0) {
                    accumulatedDistance += calculateDistance(
                        routePoints[index - 1],
                        point
                    );
                }
                
                const progress = accumulatedDistance / totalDistance;
                const pointTime = new Date(startTime.getTime() + (totalDuration * progress));
                
                point.schedule = pointTime.toISOString().slice(0, 16);
            });
            
            updateRouteDisplay();
        }

        // Calcular distancia total
        function calculateTotalDistance() {
            let total = 0;
            for (let i = 1; i < routePoints.length; i++) {
                total += calculateDistance(routePoints[i - 1], routePoints[i]);
            }
            return total;
        }

        // Calcular distancia entre dos puntos
        function calculateDistance(point1, point2) {
            const R = 6371000; // Radio de la Tierra en metros
            const lat1Rad = point1.lat * Math.PI / 180;
            const lat2Rad = point2.lat * Math.PI / 180;
            const deltaLatRad = (point2.lat - point1.lat) * Math.PI / 180;
            const deltaLngRad = (point2.lng - point1.lng) * Math.PI / 180;
            
            const a = Math.sin(deltaLatRad / 2) * Math.sin(deltaLatRad / 2) +
                     Math.cos(lat1Rad) * Math.cos(lat2Rad) *
                     Math.sin(deltaLngRad / 2) * Math.sin(deltaLngRad / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            
            return R * c;
        }

        // Iniciar seguimiento de ubicación
        function startLocationTracking() {
            if (!navigator.geolocation) {
                console.log('Geolocalización no soportada');
                return;
            }
            
            const options = {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 5000
            };
            
            watchId = navigator.geolocation.watchPosition(
                updateLocation,
                handleLocationError,
                options
            );
        }

        // Actualizar ubicación
        function updateLocation(position) {
            const lat = position.coords.latitude;
            const lng = position.coords.longitude;
            const accuracy = position.coords.accuracy;
            
            // Calcular velocidad
            if (lastKnownPosition) {
                const distance = calculateDistance(
                    { lat: lastKnownPosition.lat, lng: lastKnownPosition.lng },
                    { lat: lat, lng: lng }
                );
                const timeDiff = (Date.now() - lastKnownPosition.timestamp) / 1000; // segundos
                currentSpeed = timeDiff > 0 ? (distance / timeDiff) * 3.6 : 0; // km/h
            }
            
            lastKnownPosition = { lat, lng, timestamp: Date.now() };
            
            // Actualizar marcador de ubicación
            if (currentLocationMarker) {
                map.removeLayer(currentLocationMarker);
            }
            
            currentLocationMarker = L.marker([lat, lng], {
                icon: L.divIcon({
                    html: `<div style="background: #3b82f6; width: 16px; height: 16px; border-radius: 50%; border: 3px solid white; box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);" class="pulse"></div>`,
                    className: 'current-location-marker',
                    iconSize: [22, 22],
                    iconAnchor: [11, 11]
                })
            }).addTo(map);
            
            // Actualizar display de velocidad
            document.getElementById('speedDisplay').textContent = `${currentSpeed.toFixed(1)} km/h`;
            
            // Calcular ETA y desvío
            calculateETAAndDeviation();
        }

        // Manejar error de ubicación
        function handleLocationError(error) {
            console.log('Error de geolocalización:', error.message);
        }

        // Calcular ETA y desvío horario
        function calculateETAAndDeviation() {
            if (!lastKnownPosition || routePoints.length === 0) {
                return;
            }
            
            const now = new Date();
            let debugInfo = `🕐 Hora actual: ${now.toLocaleTimeString()}\n`;
            debugInfo += `📍 Posición: ${lastKnownPosition.lat.toFixed(6)}, ${lastKnownPosition.lng.toFixed(6)}\n`;
            debugInfo += `🏃 Velocidad: ${currentSpeed.toFixed(1)} km/h\n\n`;
            
            // Encontrar el siguiente punto programado
            let nextScheduledPoint = null;
            let currentSegment = null;
            
            for (let i = 0; i < routePoints.length; i++) {
                const point = routePoints[i];
                if (point.schedule) {
                    const scheduleTime = new Date(point.schedule);
                    if (scheduleTime > now) {
                        nextScheduledPoint = point;
                        if (i > 0) {
                            currentSegment = {
                                from: routePoints[i - 1],
                                to: point,
                                index: i
                            };
                        }
                        break;
                    }
                }
            }
            
            if (!nextScheduledPoint) {
                debugInfo += '❌ No hay puntos programados futuros\n';
                document.getElementById('debugInfo').textContent = debugInfo;
                return;
            }
            
            debugInfo += `🎯 Próximo punto: ${nextScheduledPoint.name}\n`;
            debugInfo += `⏰ Horario programado: ${new Date(nextScheduledPoint.schedule).toLocaleTimeString()}\n`;
            
            // Calcular ETA básico (tiempo hasta el horario programado)
            const scheduleTime = new Date(nextScheduledPoint.schedule);
            const timeToSchedule = scheduleTime - now;
            const etaMinutes = Math.max(0, Math.floor(timeToSchedule / 60000));
            const etaSeconds = Math.max(0, Math.floor((timeToSchedule % 60000) / 1000));
            
            debugInfo += `⏱️ ETA básico: ${etaMinutes} min ${etaSeconds} seg\n\n`;
            
            // Calcular desvío horario basado en posición en la ruta
            let deviation = 0;
            let deviationText = '00:00';
            let deviationClass = 'green';
            
            if (currentSegment && currentSegment.from.schedule) {
                debugInfo += `📏 Analizando segmento: ${currentSegment.from.name} → ${nextScheduledPoint.name}\n`;
                
                // Calcular proyección del usuario sobre el segmento
                const userPos = { lat: lastKnownPosition.lat, lng: lastKnownPosition.lng };
                const segmentStart = { lat: currentSegment.from.lat, lng: currentSegment.from.lng };
                const segmentEnd = { lat: nextScheduledPoint.lat, lng: nextScheduledPoint.lng };
                
                const projection = projectPointOnSegment(userPos, segmentStart, segmentEnd);
                const segmentLength = calculateDistance(segmentStart, segmentEnd);
                const progressDistance = calculateDistance(segmentStart, projection.point);
                const progressPercent = segmentLength > 0 ? Math.min(1, Math.max(0, progressDistance / segmentLength)) : 0;
                
                debugInfo += `📐 Progreso en segmento: ${(progressPercent * 100).toFixed(1)}%\n`;
                debugInfo += `📏 Distancia del segmento: ${segmentLength.toFixed(0)}m\n`;
                debugInfo += `📍 Distancia recorrida: ${progressDistance.toFixed(0)}m\n`;
                
                // Calcular tiempo esperado en la posición actual
                const segmentStartTime = new Date(currentSegment.from.schedule);
                const segmentDuration = scheduleTime - segmentStartTime;
                const expectedTime = new Date(segmentStartTime.getTime() + (segmentDuration * progressPercent));
                
                debugInfo += `⏰ Tiempo esperado en posición actual: ${expectedTime.toLocaleTimeString()}\n`;
                
                // Calcular desvío
                const deviationMs = expectedTime - now;
                const deviationMinutes = Math.floor(Math.abs(deviationMs) / 60000);
                const deviationSecondsOnly = Math.floor((Math.abs(deviationMs) % 60000) / 1000);
                
                if (Math.abs(deviationMs) < 30000) { // Menos de 30 segundos
                    deviationText = '00:00';
                    deviationClass = 'green';
                } else {
                    const sign = deviationMs >= 0 ? '+' : '-';
                    deviationText = `${sign}${deviationMinutes.toString().padStart(2, '0')}:${deviationSecondsOnly.toString().padStart(2, '0')}`;
                    
                    // Determinar color según las especificaciones
                    if (Math.abs(deviationMinutes) <= 2) {
                        deviationClass = 'green'; // -02:59 a +02:59
                    } else if (deviationMs < 0) {
                        deviationClass = 'blue'; // -03:00 o más atraso
                    } else {
                        deviationClass = 'red'; // +03:00 o más adelanto
                    }
                }
                
                debugInfo += `⚖️ Desvío horario: ${deviationText}\n`;
                
                // Verificar si está en el punto de inicio
                const startPoint = routePoints.find(p => p.type === 'start');
                if (startPoint) {
                    const distanceToStart = calculateDistance(userPos, startPoint);
                    debugInfo += `🏁 Distancia al punto de inicio: ${distanceToStart.toFixed(0)}m\n`;
                    
                    if (distanceToStart <= generalRadius && deviationMs > 0) {
                        debugInfo += `⏳ Dentro del radio del punto de inicio - "Haciendo hora"\n`;
                        debugInfo += `📝 Lógica aplicada: SUMAR adelanto al ETA\n`;
                        
                        // Ajustar ETA sumando el adelanto
                        const adjustedEtaMinutes = etaMinutes + deviationMinutes;
                        document.getElementById('etaDisplay').textContent = `${adjustedEtaMinutes} min.`;
                    } else {
                        debugInfo += `📝 Lógica aplicada: ETA normal\n`;
                        document.getElementById('etaDisplay').textContent = `${etaMinutes} min.`;
                    }
                } else {
                    document.getElementById('etaDisplay').textContent = `${etaMinutes} min.`;
                }
            } else {
                debugInfo += `📝 Sin segmento anterior - usando ETA básico\n`;
                document.getElementById('etaDisplay').textContent = `${etaMinutes} min.`;
            }
            
            // Actualizar displays
            const deviationElement = document.getElementById('timeDeviation');
            deviationElement.textContent = deviationText;
            deviationElement.className = `status-value deviation ${deviationClass}`;
            
            document.getElementById('debugInfo').textContent = debugInfo;
        }

        // Proyectar punto sobre segmento
        function projectPointOnSegment(point, segmentStart, segmentEnd) {
            const A = { x: segmentStart.lng, y: segmentStart.lat };
            const B = { x: segmentEnd.lng, y: segmentEnd.lat };
            const P = { x: point.lng, y: point.lat };
            
            const AB = { x: B.x - A.x, y: B.y - A.y };
            const AP = { x: P.x - A.x, y: P.y - A.y };
            
            const AB_squared = AB.x * AB.x + AB.y * AB.y;
            
            if (AB_squared === 0) {
                return { point: segmentStart, t: 0 };
            }
            
            const t = Math.max(0, Math.min(1, (AP.x * AB.x + AP.y * AB.y) / AB_squared));
            
            const projection = {
                lng: A.x + t * AB.x,
                lat: A.y + t * AB.y
            };
            
            return { point: projection, t: t };
        }

        // Iniciar actualizaciones de tiempo
        function startTimeUpdates() {
            setInterval(() => {
                const now = new Date();
                document.getElementById('currentTime').textContent = now.toLocaleTimeString();
                
                if (lastKnownPosition) {
                    calculateETAAndDeviation();
                }
            }, 1000);
        }

        // Funciones de acordeón
        function toggleAccordion(sectionId) {
            const content = document.getElementById(sectionId + '-content');
            const header = content.previousElementSibling;
            const icon = header.querySelector('.icon');
            
            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                content.classList.add('expanded');
                header.classList.remove('collapsed');
                icon.style.transform = 'rotate(0deg)';
            } else {
                content.classList.remove('expanded');
                content.classList.add('collapsed');
                header.classList.add('collapsed');
                icon.style.transform = 'rotate(180deg)';
            }
        }

        // Funciones de guardar/cargar (placeholder)
        function saveRoute() {
            const routeData = {
                points: routePoints.map(p => ({
                    type: p.type,
                    lat: p.lat,
                    lng: p.lng,
                    name: p.name,
                    schedule: p.schedule
                })),
                generalRadius: generalRadius
            };
            
            localStorage.setItem('smartMoveRoute', JSON.stringify(routeData));
            alert('Ruta guardada exitosamente');
        }

        function loadRoute() {
            const saved = localStorage.getItem('smartMoveRoute');
            if (saved) {
                const routeData = JSON.parse(saved);
                
                // Limpiar ruta actual
                clearRoute();
                
                // Cargar puntos
                routeData.points.forEach(pointData => {
                    const point = {
                        id: Date.now() + Math.random(),
                        type: pointData.type,
                        lat: pointData.lat,
                        lng: pointData.lng,
                        name: pointData.name,
                        schedule: pointData.schedule,
                        marker: null,
                        circle: null
                    };
                    
                    routePoints.push(point);
                    createPointMarker(point);
                });
                
                // Restaurar radio
                if (routeData.generalRadius) {
                    generalRadius = routeData.generalRadius;
                    document.getElementById('generalRadius').value = generalRadius;
                    updateGeneralRadius();
                }
                
                updateRouteDisplay();
                updateRoutePolyline();
                
                alert('Ruta cargada exitosamente');
            } else {
                alert('No hay ruta guardada');
            }
        }

        function exportRoute() {
            const routeData = {
                points: routePoints.map(p => ({
                    type: p.type,
                    lat: p.lat,
                    lng: p.lng,
                    name: p.name,
                    schedule: p.schedule
                })),
                generalRadius: generalRadius,
                exportDate: new Date().toISOString()
            };
            
            const dataStr = JSON.stringify(routeData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `smart_move_route_${new Date().toISOString().slice(0, 10)}.json`;
            link.click();
            
            URL.revokeObjectURL(url);
        }

        function importRoute() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const routeData = JSON.parse(e.target.result);
                            
                            // Limpiar ruta actual
                            clearRoute();
                            
                            // Cargar puntos
                            routeData.points.forEach(pointData => {
                                const point = {
                                    id: Date.now() + Math.random(),
                                    type: pointData.type,
                                    lat: pointData.lat,
                                    lng: pointData.lng,
                                    name: pointData.name,
                                    schedule: pointData.schedule,
                                    marker: null,
                                    circle: null
                                };
                                
                                routePoints.push(point);
                                createPointMarker(point);
                            });
                            
                            // Restaurar radio
                            if (routeData.generalRadius) {
                                generalRadius = routeData.generalRadius;
                                document.getElementById('generalRadius').value = generalRadius;
                                updateGeneralRadius();
                            }
                            
                            updateRouteDisplay();
                            updateRoutePolyline();
                            
                            alert('Ruta importada exitosamente');
                        } catch (error) {
                            alert('Error al importar la ruta: ' + error.message);
                        }
                    };
                    reader.readAsText(file);
                }
            };
            
            input.click();
        }
    </script>
</body>
</html>
