<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Move Pro - Asistente de Conductor</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <style>
        #map { height: 400px; width: 100%; cursor: crosshair; }
        .status-indicator {
            font-size: 2.5rem; font-weight: bold; text-align: center;
            padding: 20px; border-radius: 10px; color: white;
            transition: background-color 0.3s ease;
        }
        .status-ontime { background-color: #22c55e; }
        .status-late { background-color: #ef4444; }
        .status-early { background-color: #3b82f6; }
        .status-inactive { background-color: #6b7280; }
        .stop-item-btn {
            background: none; border: none; cursor: pointer;
            margin-left: 8px; vertical-align: middle;
        }
        .creation-guide {
            background-color: #eef2ff; color: #4338ca; border-left: 4px solid #4f46e5;
            padding: 12px; margin-bottom: 1rem; border-radius: 4px;
            font-weight: 500;
        }
    </style>
</head>
<body class="bg-gray-100 font-sans">

    <div class="container mx-auto p-4 max-w-4xl">

        <header class="bg-white shadow-md rounded-lg p-4 mb-6">
            <h1 class="text-3xl font-bold text-gray-800">Smart Move Pro</h1>
            <p class="text-gray-600">Tu asistente de recorrido en tiempo real.</p>
        </header>

        <main class="grid grid-cols-1 md:grid-cols-3 gap-6">

            <!-- Columna de Gestión de Recorrido -->
            <div class="md:col-span-1 bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Gestión de Recorrido</h2>
                
                <div class="mb-4">
                    <label for="recorrido-select" class="block text-sm font-medium text-gray-700 mb-1">Seleccionar Recorrido:</label>
                    <div class="flex items-center space-x-2">
                        <select id="recorrido-select" class="w-full p-2 border border-gray-300 rounded-md shadow-sm"></select>
                        <button id="delete-recorrido-btn" title="Eliminar Recorrido" class="p-2 bg-red-600 hover:bg-red-700 text-white rounded-md">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clip-rule="evenodd" /></svg>
                        </button>
                    </div>
                </div>

                <div class="mb-4">
                    <label for="radius-input" class="block text-sm font-medium text-gray-700 mb-1">Radio de Parada (metros):</label>
                    <input type="number" id="radius-input" value="20" min="5" class="w-full p-2 border border-gray-300 rounded-md shadow-sm">
                </div>
                
                <div class="mb-4 flex items-center">
                    <input type="checkbox" id="auto-calc-checkbox" class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                    <label for="auto-calc-checkbox" class="ml-2 block text-sm text-gray-900">Calcular horarios intermedios</label>
                </div>

                <div class="flex space-x-2 mb-4">
                    <button id="start-btn" class="flex-1 bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-md transition">Iniciar</button>
                    <button id="stop-btn" class="flex-1 bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-md transition" disabled>Detener</button>
                </div>
                <hr class="my-4">
                <div class="mb-4">
                    <label for="new-recorrido-name" class="block text-sm font-medium text-gray-700 mb-1">Nombre Nuevo Recorrido:</label>
                    <input type="text" id="new-recorrido-name" placeholder="Ej: Línea 106 - Ramal A" class="w-full p-2 border border-gray-300 rounded-md shadow-sm">
                    <button id="create-recorrido-btn" class="mt-2 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md transition">Crear Recorrido</button>
                </div>
                <div>
                    <div id="creation-guide-container" class="hidden"></div>
                    <h3 class="text-lg font-semibold mb-2">Puntos del Recorrido</h3>
                    <ul id="stops-list" class="space-y-2 bg-gray-50 p-3 rounded-md h-48 overflow-y-auto"></ul>
                </div>
            </div>

            <!-- Columna de Mapa y Estado -->
            <div class="md:col-span-2 bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Estado y Mapa</h2>
                <div id="status-indicator" class="status-indicator status-inactive mb-2">--:--</div>
                <p id="current-stop-info" class="text-center text-green-600 font-bold h-6 mb-1 hidden"></p>
                <p id="next-stop-info" class="text-center text-gray-700 font-semibold h-6 mb-3"></p>
                <div id="map" class="rounded-lg border border-gray-300"></div>
                <p class="text-xs text-gray-500 mt-1 text-center">Haz clic en el mapa para agregar un punto al recorrido activo.</p>
            </div>
        </main>
    </div>

    <!-- Modal para agregar/editar punto -->
    <div id="stop-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full hidden">
        <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
            <div class="mt-3 text-center">
                <h3 id="modal-title" class="text-lg leading-6 font-medium text-gray-900"></h3>
                <div class="mt-2 px-7 py-3">
                    <div id="point-type-container" class="mb-3">
                        <label for="point-type-select" class="block text-sm font-medium text-gray-700 mb-1">Tipo de Punto:</label>
                        <select id="point-type-select" class="w-full p-2 border border-gray-300 rounded-md shadow-sm">
                            <option value="stop">Parada</option>
                            <option value="waypoint">Punto de Paso</option>
                        </select>
                    </div>
                    <div id="point-name-container" class="mb-3">
                        <input type="text" id="stop-name" placeholder="Nombre (opcional)" class="w-full p-2 border border-gray-300 rounded-md">
                    </div>
                    <div id="time-input-container">
                        <label for="stop-time" class="text-sm text-gray-600">Hora programada:</label>
                        <input type="time" id="stop-time" class="w-full p-2 border border-gray-300 rounded-md">
                    </div>
                </div>
                <div class="items-center px-4 py-3">
                    <button id="save-stop-btn" class="px-4 py-2 bg-green-500 text-white text-base font-medium rounded-md w-full shadow-sm hover:bg-green-600">Guardar</button>
                    <button id="cancel-stop-btn" class="mt-2 px-4 py-2 bg-gray-500 text-white text-base font-medium rounded-md w-full shadow-sm hover:bg-gray-600">Cancelar</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- VARIABLES GLOBALES ---
            let map, driverMarker, currentRecorrido, gpsInterval, timeUpdateInterval, tempStopCoords;
            let recorridos = {};
            let currentDriverLatLng = null;
            let editingStopIndex = null;
            let stopRadius = 20;
            let radiusCircles = [];

            // --- ELEMENTOS DEL DOM ---
            const recorridoSelect = document.getElementById('recorrido-select');
            const startBtn = document.getElementById('start-btn');
            const stopBtn = document.getElementById('stop-btn');
            const createRecorridoBtn = document.getElementById('create-recorrido-btn');
            const newRecorridoNameInput = document.getElementById('new-recorrido-name');
            const deleteRecorridoBtn = document.getElementById('delete-recorrido-btn');
            const radiusInput = document.getElementById('radius-input');
            const autoCalcCheckbox = document.getElementById('auto-calc-checkbox');
            const stopsList = document.getElementById('stops-list');
            const statusIndicator = document.getElementById('status-indicator');
            const currentStopInfo = document.getElementById('current-stop-info');
            const nextStopInfo = document.getElementById('next-stop-info');
            const mapElement = document.getElementById('map');
            const creationGuideContainer = document.getElementById('creation-guide-container');
            
            // Modal
            const stopModal = document.getElementById('stop-modal');
            const modalTitle = document.getElementById('modal-title');
            const saveStopBtn = document.getElementById('save-stop-btn');
            const cancelStopBtn = document.getElementById('cancel-stop-btn');
            const pointTypeContainer = document.getElementById('point-type-container');
            const pointTypeSelect = document.getElementById('point-type-select');
            const pointNameContainer = document.getElementById('point-name-container');
            const stopNameInput = document.getElementById('stop-name');
            const timeInputContainer = document.getElementById('time-input-container');
            const stopTimeInput = document.getElementById('stop-time');

            // --- INICIALIZACIÓN ---
            function initializeMap() {
                map = L.map(mapElement).setView([-27.46, -58.83], 13);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(map);
                const driverIcon = L.icon({
                    iconUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon-2x.png',
                    iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
                });
                driverMarker = L.marker([0, 0], { icon: driverIcon }).addTo(map).bindPopup("Tu posición");
                map.on('click', onMapClick);
            }

            function loadRecorridosFromStorage() {
                const storedRecorridos = localStorage.getItem('busRecorridos');
                if (storedRecorridos) recorridos = JSON.parse(storedRecorridos);
                updateRecorridoSelector();
            }

            function saveRecorridosToStorage() {
                localStorage.setItem('busRecorridos', JSON.stringify(recorridos));
            }

            // --- GESTIÓN DE RECORRIDOS Y PUNTOS ---
            function updateRecorridoSelector() {
                const currentSelection = recorridoSelect.value;
                recorridoSelect.innerHTML = '<option value="">-- Selecciona un recorrido --</option>';
                for (const recorridoName in recorridos) {
                    const option = document.createElement('option');
                    option.value = recorridoName;
                    option.textContent = recorridoName;
                    recorridoSelect.appendChild(option);
                }
                recorridoSelect.value = currentSelection;
                if (!recorridoSelect.value && Object.keys(recorridos).length > 0) {
                    recorridoSelect.value = Object.keys(recorridos)[0];
                }
                updateUIForSelectedRecorrido();
            }

            function updateUIForSelectedRecorrido() {
                const selectedRecorrido = recorridoSelect.value;
                updateCreationGuide(selectedRecorrido);
                updateStopsList(selectedRecorrido);
                drawRecorridoOnMap(selectedRecorrido);
            }
            
            function updateStopsList(recorridoName) {
                stopsList.innerHTML = '';
                const points = recorridos[recorridoName] || [];
                if (points.length === 0) {
                    stopsList.innerHTML = '<li class="text-gray-500">No hay puntos.</li>';
                } else {
                    points.forEach((point, index) => {
                        const li = document.createElement('li');
                        li.className = 'flex justify-between items-center bg-white p-2 rounded-md shadow-sm';
                        const icon = point.type === 'stop' ? '🅿️' : '➡️';
                        const name = point.name || (point.type === 'stop' ? `Parada ${index + 1}` : `Punto ${index + 1}`);
                        li.innerHTML = `
                            <span>${icon} ${name} - ${point.time || 'N/A'}</span>
                            <div>
                                <button title="Eliminar Punto" class="stop-item-btn delete-stop-btn text-red-600" data-index="${index}"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clip-rule="evenodd" /></svg></button>
                            </div>`;
                        stopsList.appendChild(li);
                    });
                }
            }

            function updateCreationGuide(recorridoName) {
                const points = recorridos[recorridoName] || [];
                let guideText = '';
                if (recorridoName) {
                    if (points.length === 0) {
                        guideText = '1. Haz clic en el mapa para añadir la <b>primera parada</b>.';
                    } else if (points.length === 1) {
                        guideText = '2. Haz clic para añadir la <b>última parada</b>.';
                    } else {
                        guideText = '3. Añade <b>puntos intermedios</b> o inicia el recorrido.';
                    }
                }
                if (guideText) {
                    creationGuideContainer.innerHTML = `<div class="creation-guide">${guideText}</div>`;
                    creationGuideContainer.classList.remove('hidden');
                } else {
                    creationGuideContainer.classList.add('hidden');
                }
            }

            createRecorridoBtn.addEventListener('click', () => {
                const recorridoName = newRecorridoNameInput.value.trim();
                if (recorridoName && !recorridos[recorridoName]) {
                    recorridos[recorridoName] = [];
                    saveRecorridosToStorage();
                    newRecorridoNameInput.value = '';
                    updateRecorridoSelector();
                    recorridoSelect.value = recorridoName;
                } else {
                    alert(recorridos[recorridoName] ? 'Error: Ya existe un recorrido con ese nombre.' : 'Error: Ingresa un nombre válido.');
                }
            });

            deleteRecorridoBtn.addEventListener('click', () => {
                const recorridoName = recorridoSelect.value;
                if (!recorridoName) return;
                if (confirm(`¿Estás seguro de que quieres eliminar el recorrido "${recorridoName}"?`)) {
                    delete recorridos[recorridoName];
                    saveRecorridosToStorage();
                    recorridoSelect.value = '';
                    updateRecorridoSelector();
                }
            });

            recorridoSelect.addEventListener('change', updateUIForSelectedRecorrido);
            radiusInput.addEventListener('change', () => {
                stopRadius = parseInt(radiusInput.value) || 20;
                drawRecorridoOnMap(recorridoSelect.value);
            });
            autoCalcCheckbox.addEventListener('change', () => {
                if (autoCalcCheckbox.checked) {
                    calculateIntermediateTimes(recorridoSelect.value);
                }
                updateUIForSelectedRecorrido();
            });

            function onMapClick(e) {
                const selectedRecorrido = recorridoSelect.value;
                if (!selectedRecorrido) {
                    alert("Por favor, crea o selecciona un recorrido primero.");
                    return;
                }
                tempStopCoords = e.latlng;
                const points = recorridos[selectedRecorrido];

                if (points.length < 2) {
                    modalTitle.textContent = points.length === 0 ? "Definir Primera Parada" : "Definir Última Parada";
                    pointTypeContainer.style.display = 'none';
                    pointNameContainer.style.display = 'block';
                    timeInputContainer.style.display = 'block';
                } else {
                    modalTitle.textContent = "Añadir Punto Intermedio";
                    pointTypeContainer.style.display = 'block';
                    timeInputContainer.style.display = autoCalcCheckbox.checked ? 'none' : 'block';
                    toggleNameForWaypoint();
                }
                
                pointTypeSelect.value = 'stop';
                stopNameInput.value = '';
                stopTimeInput.value = '';
                stopModal.classList.remove('hidden');
            }
            
            pointTypeSelect.addEventListener('change', toggleNameForWaypoint);
            function toggleNameForWaypoint() {
                pointNameContainer.style.display = pointTypeSelect.value === 'waypoint' ? 'none' : 'block';
            }

            saveStopBtn.addEventListener('click', () => {
                const stopName = stopNameInput.value.trim();
                let stopTime = stopTimeInput.value;
                const pointType = pointTypeSelect.value;
                const selectedRecorrido = recorridoSelect.value;
                const points = recorridos[selectedRecorrido];

                let newPoint;
                if (points.length < 2) {
                    if (!stopTime) { alert("La hora es obligatoria."); return; }
                    newPoint = { name: stopName, time: stopTime, type: 'stop', lat: tempStopCoords.lat, lng: tempStopCoords.lng };
                    points.push(newPoint);
                } else {
                    if (autoCalcCheckbox.checked) {
                        stopTime = null;
                    } else if (!stopTime) {
                        alert("La hora es obligatoria si el cálculo automático está desactivado."); return;
                    }
                    newPoint = { name: stopName, time: stopTime, type: pointType, lat: tempStopCoords.lat, lng: tempStopCoords.lng };
                    points.splice(points.length - 1, 0, newPoint);
                }
                
                if (autoCalcCheckbox.checked) {
                    calculateIntermediateTimes(selectedRecorrido);
                }

                saveRecorridosToStorage();
                updateUIForSelectedRecorrido();
                stopModal.classList.add('hidden');
            });

            cancelStopBtn.addEventListener('click', () => stopModal.classList.add('hidden'));

            stopsList.addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if (!button || !button.classList.contains('delete-stop-btn')) return;
                
                const recorridoName = recorridoSelect.value;
                const stopIndex = parseInt(button.dataset.index);

                if (confirm("¿Estás seguro de que quieres eliminar este punto?")) {
                    recorridos[recorridoName].splice(stopIndex, 1);
                    if (autoCalcCheckbox.checked) {
                        calculateIntermediateTimes(recorridoName);
                    }
                    saveRecorridosToStorage();
                    updateUIForSelectedRecorrido();
                }
            });

            function calculateIntermediateTimes(recorridoName) {
                const points = recorridos[recorridoName];
                if (!points || points.length < 2) return;
                const firstPoint = points[0];
                const lastPoint = points[points.length - 1];
                if (!firstPoint.time || !lastPoint.time) return;

                const today = new Date().toISOString().split('T')[0];
                const startTime = new Date(`${today}T${firstPoint.time}`).getTime();
                const endTime = new Date(`${today}T${lastPoint.time}`).getTime();
                const totalDurationMs = endTime - startTime;
                if (totalDurationMs <= 0) return;

                let totalDistance = 0;
                for (let i = 0; i < points.length - 1; i++) {
                    const from = L.latLng(points[i].lat, points[i].lng);
                    const to = L.latLng(points[i+1].lat, points[i+1].lng);
                    points[i].distanceToNext = from.distanceTo(to);
                    totalDistance += points[i].distanceToNext;
                }
                if (totalDistance === 0) return;

                let cumulativeDistance = 0;
                for (let i = 1; i < points.length - 1; i++) {
                    cumulativeDistance += points[i-1].distanceToNext;
                    const progress = cumulativeDistance / totalDistance;
                    const pointTimeMs = startTime + (totalDurationMs * progress);
                    const pointDate = new Date(pointTimeMs);
                    points[i].time = `${String(pointDate.getHours()).padStart(2, '0')}:${String(pointDate.getMinutes()).padStart(2, '0')}:${String(pointDate.getSeconds()).padStart(2, '0')}`;
                }
                saveRecorridosToStorage();
            }

            // --- LÓGICA DE SEGUIMIENTO EN TIEMPO REAL ---
            startBtn.addEventListener('click', () => {
                const selectedRecorrido = recorridoSelect.value;
                if (!selectedRecorrido || recorridos[selectedRecorrido].length < 2) {
                    alert("Selecciona un recorrido con al menos 2 puntos para iniciar.");
                    return;
                }
                currentRecorrido = { name: selectedRecorrido, stops: recorridos[selectedRecorrido], lastVisitedStopIndex: -1, currentTargetIndex: 0 };
                startBtn.disabled = true; stopBtn.disabled = false; recorridoSelect.disabled = true; createRecorridoBtn.disabled = true; deleteRecorridoBtn.disabled = true; radiusInput.disabled = true; autoCalcCheckbox.disabled = true;
                
                if (navigator.geolocation) {
                    gpsInterval = navigator.geolocation.watchPosition(updateDriverPosition, handleLocationError, { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 });
                } else {
                    alert("Geolocalización no es soportada.");
                    stopTracking();
                }
                timeUpdateInterval = setInterval(updateTimeDisplay, 1000);
            });
            
            stopBtn.addEventListener('click', stopTracking);

            function stopTracking() {
                if (gpsInterval) navigator.geolocation.clearWatch(gpsInterval);
                if (timeUpdateInterval) clearInterval(timeUpdateInterval);
                currentRecorrido = null; gpsInterval = null; timeUpdateInterval = null; currentDriverLatLng = null;
                startBtn.disabled = false; stopBtn.disabled = true; recorridoSelect.disabled = false; createRecorridoBtn.disabled = false; deleteRecorridoBtn.disabled = false; radiusInput.disabled = false; autoCalcCheckbox.disabled = false;
                updateStatus('--:--', 'inactive');
                nextStopInfo.textContent = '';
                currentStopInfo.classList.add('hidden');
                currentStopInfo.textContent = '';
            }

            function updateDriverPosition(position) {
                currentDriverLatLng = L.latLng(position.coords.latitude, position.coords.longitude);
                driverMarker.setLatLng(currentDriverLatLng);
                if (currentRecorrido) checkRecorridoStatus(currentDriverLatLng);
            }

            // MODIFICADO: Lógica de estado con prioridad de parada actual
            function checkRecorridoStatus(driverLatLng) {
                if (!currentRecorrido) return;

                // 1. Prioridad #1: Comprobar si estamos en el radio de CUALQUIER parada
                let inRadiusOfAnyStop = null;
                for (let i = 0; i < currentRecorrido.stops.length; i++) {
                    const stop = currentRecorrido.stops[i];
                    if (stop.type === 'stop' && driverLatLng.distanceTo(L.latLng(stop.lat, stop.lng)) <= stopRadius) {
                        inRadiusOfAnyStop = { stop: stop, index: i };
                        break;
                    }
                }

                if (inRadiusOfAnyStop) {
                    currentStopInfo.textContent = `PARADA ACTUAL: ${inRadiusOfAnyStop.stop.name || `Parada ${inRadiusOfAnyStop.index + 1}`}`;
                    currentStopInfo.classList.remove('hidden');
                    // Actualizar la última parada visitada si hemos llegado a una nueva
                    if (inRadiusOfAnyStop.index > currentRecorrido.lastVisitedStopIndex) {
                        currentRecorrido.lastVisitedStopIndex = inRadiusOfAnyStop.index;
                    }
                } else {
                    currentStopInfo.classList.add('hidden');
                }

                // 2. Determinar el siguiente objetivo para cálculo y visualización
                let closestPointIndex = -1;
                let minDistance = Infinity;
                for (let i = currentRecorrido.lastVisitedStopIndex + 1; i < currentRecorrido.stops.length; i++) {
                    const distance = driverLatLng.distanceTo(L.latLng(currentRecorrido.stops[i].lat, currentRecorrido.stops[i].lng));
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestPointIndex = i;
                    }
                }
                
                if (closestPointIndex === -1) {
                    nextStopInfo.textContent = 'Recorrido Finalizado.';
                    updateStatus('FIN', 'ontime');
                    stopTracking();
                    return;
                }
                currentRecorrido.currentTargetIndex = closestPointIndex;

                // 3. Mostrar la PRÓXIMA PARADA (ignorando puntos de paso)
                let nextDisplayStopIndex = currentRecorrido.lastVisitedStopIndex + 1;
                while(nextDisplayStopIndex < currentRecorrido.stops.length && currentRecorrido.stops[nextDisplayStopIndex].type !== 'stop') {
                    nextDisplayStopIndex++;
                }

                if (nextDisplayStopIndex < currentRecorrido.stops.length) {
                    const nextDisplayStop = currentRecorrido.stops[nextDisplayStopIndex];
                    nextStopInfo.textContent = `PRÓXIMA PARADA: ${nextDisplayStop.name || `Parada ${nextDisplayStopIndex + 1}`}`;
                } else {
                    nextStopInfo.textContent = 'Última parada como objetivo.';
                }
            }
            
            function updateTimeDisplay() {
                if (!currentRecorrido || !currentDriverLatLng || currentRecorrido.currentTargetIndex === -1) return;
                
                const targetPoint = currentRecorrido.stops[currentRecorrido.currentTargetIndex];
                const prevIndex = currentRecorrido.lastVisitedStopIndex;

                if (prevIndex < 0) {
                    if (!targetPoint.time) return;
                    const today = new Date();
                    const dateString = today.toISOString().split('T')[0];
                    const scheduledTimeMs = new Date(`${dateString}T${targetPoint.time}`).getTime();
                    const deviationMs = today.getTime() - scheduledTimeMs;
                    formatAndDisplayDeviation(deviationMs);
                    return;
                }

                const previousPoint = currentRecorrido.stops[prevIndex];
                if (!previousPoint.time || !targetPoint.time) return;

                const prevPointLatLng = L.latLng(previousPoint.lat, previousPoint.lng);
                const targetPointLatLng = L.latLng(targetPoint.lat, targetPoint.lng);
                const totalSegmentDistance = prevPointLatLng.distanceTo(targetPointLatLng);
                const distanceFromPrevPoint = currentDriverLatLng.distanceTo(prevPointLatLng);
                let progress = totalSegmentDistance > 1 ? distanceFromPrevPoint / totalSegmentDistance : 0;
                progress = Math.max(0, Math.min(1, progress));
                const today = new Date();
                const dateString = today.toISOString().split('T')[0];
                const prevScheduledTimeMs = new Date(`${dateString}T${previousPoint.time}`).getTime();
                const nextScheduledTimeMs = new Date(`${dateString}T${targetPoint.time}`).getTime();
                const totalSegmentTimeMs = nextScheduledTimeMs - prevScheduledTimeMs;
                const expectedTimeAtPositionMs = prevScheduledTimeMs + (totalSegmentTimeMs * progress);
                const deviationMs = today.getTime() - expectedTimeAtPositionMs;
                formatAndDisplayDeviation(deviationMs);
            }
            
            function formatAndDisplayDeviation(deviationMs) {
                const diffSeconds = Math.round(deviationMs / 1000);
                const absDiffSeconds = Math.abs(diffSeconds);
                const displayMinutes = String(Math.floor(absDiffSeconds / 60)).padStart(2, '0');
                const displaySeconds = String(absDiffSeconds % 60).padStart(2, '0');
                let text, statusClass;
                if (diffSeconds > 30) { text = `-${displayMinutes}:${displaySeconds}`; statusClass = 'late'; } 
                else if (diffSeconds < -30) { text = `+${displayMinutes}:${displaySeconds}`; statusClass = 'early'; } 
                else { text = '00:00'; statusClass = 'ontime'; }
                statusIndicator.textContent = text;
                statusIndicator.className = `status-indicator status-${statusClass}`;
            }

            function handleLocationError(error) {
                console.error("Error de Geolocalización: ", error);
                alert(`Error al obtener la ubicación: ${error.message}`);
                stopTracking();
            }

            // --- FUNCIONES DEL MAPA ---
            let recorridoPolyline = null;
            let stopMarkers = [];

            function clearMapLayers() {
                if (recorridoPolyline) map.removeLayer(recorridoPolyline);
                stopMarkers.forEach(marker => map.removeLayer(marker));
                radiusCircles.forEach(circle => map.removeLayer(circle));
                recorridoPolyline = null; stopMarkers = []; radiusCircles = [];
            }

            function drawRecorridoOnMap(recorridoName) {
                clearMapLayers();
                const stops = recorridos[recorridoName];
                if (!stops || stops.length < 1) return;
                const latLngs = stops.map(stop => [stop.lat, stop.lng]);
                recorridoPolyline = L.polyline(latLngs, { color: 'blue' }).addTo(map);
                stops.forEach((stop, index) => {
                    let marker;
                    const name = stop.name || (stop.type === 'stop' ? `Parada ${index + 1}` : `Punto ${index + 1}`);
                    if (stop.type === 'stop') {
                        marker = L.marker([stop.lat, stop.lng]).addTo(map).bindPopup(`<b>Parada: ${name}</b><br>Hora: ${stop.time || 'N/A'}`);
                        const circle = L.circle([stop.lat, stop.lng], { radius: stopRadius, color: '#16a34a', fillColor: '#22c55e', fillOpacity: 0.2, weight: 1 }).addTo(map);
                        radiusCircles.push(circle);
                    } else { // waypoint
                        marker = L.circleMarker([stop.lat, stop.lng], { radius: 5, color: 'gray', fillColor: '#6b7280', fillOpacity: 1 }).addTo(map).bindPopup(`<b>Punto de Paso: ${name}</b><br>Hora: ${stop.time || 'N/A'}`);
                    }
                    stopMarkers.push(marker);
                });
                if(stops.length > 0) map.fitBounds(recorridoPolyline.getBounds());
            }

            // --- INICIO DE LA APLICACIÓN ---
            initializeMap();
            loadRecorridosFromStorage();
        });
    </script>

</body>
</html>
