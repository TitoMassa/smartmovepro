<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Move Pro - Asistente de Conductor</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <style>
        #map { height: 400px; width: 100%; }
        .status-indicator {
            font-size: 2.5rem; font-weight: bold; text-align: center;
            padding: 20px; border-radius: 10px; color: white;
            transition: background-color 0.3s ease;
        }
        .status-ontime { background-color: #22c55e; }
        .status-late { background-color: #ef4444; }
        .status-early { background-color: #3b82f6; }
        .status-inactive { background-color: #6b7280; }
        .stop-item-btn {
            background: none; border: none; cursor: pointer;
            margin-left: 8px; vertical-align: middle;
        }
    </style>
</head>
<body class="bg-gray-100 font-sans">

    <div class="container mx-auto p-4 max-w-4xl">

        <header class="bg-white shadow-md rounded-lg p-4 mb-6">
            <h1 class="text-3xl font-bold text-gray-800">Smart Move Pro</h1>
            <p class="text-gray-600">Tu asistente de recorrido en tiempo real.</p>
        </header>

        <main class="grid grid-cols-1 md:grid-cols-3 gap-6">

            <!-- Columna de Gestión de Recorrido -->
            <div class="md:col-span-1 bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Gestión de Recorrido</h2>
                
                <div class="mb-4">
                    <label for="recorrido-select" class="block text-sm font-medium text-gray-700 mb-1">Seleccionar Recorrido:</label>
                    <div class="flex items-center space-x-2">
                        <select id="recorrido-select" class="w-full p-2 border border-gray-300 rounded-md shadow-sm"></select>
                        <!-- NUEVO: Botón para eliminar recorrido -->
                        <button id="delete-recorrido-btn" class="p-2 bg-red-600 hover:bg-red-700 text-white rounded-md">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clip-rule="evenodd" /></svg>
                        </button>
                    </div>
                </div>

                <div class="flex space-x-2 mb-4">
                    <button id="start-btn" class="flex-1 bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-md transition">Iniciar</button>
                    <button id="stop-btn" class="flex-1 bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-md transition" disabled>Detener</button>
                </div>
                <hr class="my-4">
                <div class="mb-4">
                    <label for="new-recorrido-name" class="block text-sm font-medium text-gray-700 mb-1">Nombre Nuevo Recorrido:</label>
                    <input type="text" id="new-recorrido-name" placeholder="Ej: Línea 106 - Ramal A" class="w-full p-2 border border-gray-300 rounded-md shadow-sm">
                    <button id="create-recorrido-btn" class="mt-2 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md transition">Crear Recorrido</button>
                </div>
                <div>
                    <h3 class="text-lg font-semibold mb-2">Paradas del Recorrido</h3>
                    <ul id="stops-list" class="space-y-2 bg-gray-50 p-3 rounded-md h-48 overflow-y-auto"></ul>
                </div>
            </div>

            <!-- Columna de Mapa y Estado -->
            <div class="md:col-span-2 bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Estado y Mapa</h2>
                <div id="status-indicator" class="status-indicator status-inactive mb-2">--:--</div>
                <p id="next-stop-info" class="text-center text-gray-700 font-semibold h-6 mb-3"></p>
                <div id="map" class="rounded-lg border border-gray-300"></div>
                <p class="text-xs text-gray-500 mt-1 text-center">Haz clic en el mapa para agregar una parada al recorrido activo.</p>
            </div>
        </main>
    </div>

    <!-- Modal para agregar/editar parada -->
    <div id="stop-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full hidden">
        <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
            <div class="mt-3 text-center">
                <h3 id="modal-title" class="text-lg leading-6 font-medium text-gray-900"></h3>
                <div class="mt-2 px-7 py-3">
                    <input type="text" id="stop-name" placeholder="Nombre de la parada" class="w-full p-2 border border-gray-300 rounded-md mb-3">
                    <label for="stop-time" class="text-sm text-gray-600">Hora programada:</label>
                    <input type="time" id="stop-time" class="w-full p-2 border border-gray-300 rounded-md">
                </div>
                <div class="items-center px-4 py-3">
                    <button id="save-stop-btn" class="px-4 py-2 bg-green-500 text-white text-base font-medium rounded-md w-full shadow-sm hover:bg-green-600">Guardar</button>
                    <button id="cancel-stop-btn" class="mt-2 px-4 py-2 bg-gray-500 text-white text-base font-medium rounded-md w-full shadow-sm hover:bg-gray-600">Cancelar</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- VARIABLES GLOBALES ---
            let map, driverMarker, currentRecorrido, gpsInterval, timeUpdateInterval, tempStopCoords;
            let recorridos = {};
            let currentDriverLatLng = null;
            let editingStopIndex = null; // NUEVO: Para saber qué parada se edita
            const PROXIMITY_THRESHOLD_METERS = 50;

            // --- ELEMENTOS DEL DOM ---
            const recorridoSelect = document.getElementById('recorrido-select');
            const startBtn = document.getElementById('start-btn');
            const stopBtn = document.getElementById('stop-btn');
            const createRecorridoBtn = document.getElementById('create-recorrido-btn');
            const newRecorridoNameInput = document.getElementById('new-recorrido-name');
            const deleteRecorridoBtn = document.getElementById('delete-recorrido-btn');
            const stopsList = document.getElementById('stops-list');
            const statusIndicator = document.getElementById('status-indicator');
            const nextStopInfo = document.getElementById('next-stop-info');
            const mapElement = document.getElementById('map');
            
            // Modal
            const stopModal = document.getElementById('stop-modal');
            const modalTitle = document.getElementById('modal-title');
            const saveStopBtn = document.getElementById('save-stop-btn');
            const cancelStopBtn = document.getElementById('cancel-stop-btn');
            const stopNameInput = document.getElementById('stop-name');
            const stopTimeInput = document.getElementById('stop-time');

            // --- INICIALIZACIÓN ---
            function initializeMap() {
                map = L.map(mapElement).setView([-27.46, -58.83], 13);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(map);
                const driverIcon = L.icon({
                    iconUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon-2x.png',
                    iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
                });
                driverMarker = L.marker([0, 0], { icon: driverIcon }).addTo(map).bindPopup("Tu posición");
                map.on('click', onMapClick);
            }

            function loadRecorridosFromStorage() {
                const storedRecorridos = localStorage.getItem('busRecorridos');
                if (storedRecorridos) recorridos = JSON.parse(storedRecorridos);
                updateRecorridoSelector();
            }

            function saveRecorridosToStorage() {
                localStorage.setItem('busRecorridos', JSON.stringify(recorridos));
            }

            // --- GESTIÓN DE RECORRIDOS Y PARADAS ---
            function updateRecorridoSelector() {
                recorridoSelect.innerHTML = '<option value="">-- Selecciona un recorrido --</option>';
                for (const recorridoName in recorridos) {
                    const option = document.createElement('option');
                    option.value = recorridoName;
                    option.textContent = recorridoName;
                    recorridoSelect.appendChild(option);
                }
                updateStopsList(recorridoSelect.value);
                drawRecorridoOnMap(recorridoSelect.value);
            }
            
            // MODIFICADO: Ahora crea botones de editar/eliminar
            function updateStopsList(recorridoName) {
                stopsList.innerHTML = '';
                const stops = recorridos[recorridoName] || [];
                if (stops.length === 0) {
                    stopsList.innerHTML = '<li class="text-gray-500">No hay paradas.</li>';
                } else {
                    stops.forEach((stop, index) => {
                        const li = document.createElement('li');
                        li.className = 'flex justify-between items-center bg-white p-2 rounded-md shadow-sm';
                        li.innerHTML = `
                            <span>${index + 1}. ${stop.name} - ${stop.time}</span>
                            <div>
                                <button class="stop-item-btn edit-stop-btn text-blue-600" data-index="${index}">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M17.414 2.586a2 2 0 00-2.828 0L7 10.172V13h2.828l7.586-7.586a2 2 0 000-2.828z" /><path fill-rule="evenodd" d="M2 6a2 2 0 012-2h4a1 1 0 010 2H4v10h10v-4a1 1 0 112 0v4a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" clip-rule="evenodd" /></svg>
                                </button>
                                <button class="stop-item-btn delete-stop-btn text-red-600" data-index="${index}">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clip-rule="evenodd" /></svg>
                                </button>
                            </div>
                        `;
                        stopsList.appendChild(li);
                    });
                }
            }

            createRecorridoBtn.addEventListener('click', () => {
                const recorridoName = newRecorridoNameInput.value.trim();
                if (recorridoName && !recorridos[recorridoName]) {
                    recorridos[recorridoName] = [];
                    saveRecorridosToStorage();
                    newRecorridoNameInput.value = '';
                    updateRecorridoSelector();
                    recorridoSelect.value = recorridoName;
                } else {
                    alert(recorridos[recorridoName] ? 'Error: Ya existe un recorrido con ese nombre.' : 'Error: Ingresa un nombre válido.');
                }
            });

            deleteRecorridoBtn.addEventListener('click', () => {
                const recorridoName = recorridoSelect.value;
                if (!recorridoName) {
                    alert("Selecciona un recorrido para eliminar.");
                    return;
                }
                if (confirm(`¿Estás seguro de que quieres eliminar el recorrido "${recorridoName}"? Esta acción no se puede deshacer.`)) {
                    delete recorridos[recorridoName];
                    saveRecorridosToStorage();
                    updateRecorridoSelector();
                }
            });

            recorridoSelect.addEventListener('change', () => {
                const selectedRecorrido = recorridoSelect.value;
                updateStopsList(selectedRecorrido);
                drawRecorridoOnMap(selectedRecorrido);
            });

            function onMapClick(e) {
                if (!recorridoSelect.value) {
                    alert("Por favor, selecciona o crea un recorrido antes de añadir paradas.");
                    return;
                }
                editingStopIndex = null; // Asegurarse de que estamos agregando, no editando
                modalTitle.textContent = "Agregar Nueva Parada";
                stopNameInput.value = '';
                stopTimeInput.value = '';
                tempStopCoords = e.latlng;
                stopModal.classList.remove('hidden');
            }

            saveStopBtn.addEventListener('click', () => {
                const stopName = stopNameInput.value.trim();
                const stopTime = stopTimeInput.value;
                const selectedRecorrido = recorridoSelect.value;

                if (!stopName || !stopTime || !selectedRecorrido) {
                    alert("Por favor, completa todos los campos.");
                    return;
                }

                if (editingStopIndex !== null) { // Editando una parada existente
                    const stopToEdit = recorridos[selectedRecorrido][editingStopIndex];
                    stopToEdit.name = stopName;
                    stopToEdit.time = stopTime;
                } else { // Agregando una nueva parada
                    const newStop = { name: stopName, time: stopTime, lat: tempStopCoords.lat, lng: tempStopCoords.lng };
                    recorridos[selectedRecorrido].push(newStop);
                }

                recorridos[selectedRecorrido].sort((a, b) => a.time.localeCompare(b.time));
                saveRecorridosToStorage();
                updateStopsList(selectedRecorrido);
                drawRecorridoOnMap(selectedRecorrido);
                stopModal.classList.add('hidden');
                editingStopIndex = null;
            });

            cancelStopBtn.addEventListener('click', () => {
                stopModal.classList.add('hidden');
                editingStopIndex = null;
            });

            // NUEVO: Manejador de eventos para botones de la lista de paradas
            stopsList.addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if (!button) return;

                const recorridoName = recorridoSelect.value;
                const stopIndex = parseInt(button.dataset.index);

                if (button.classList.contains('edit-stop-btn')) {
                    const stop = recorridos[recorridoName][stopIndex];
                    editingStopIndex = stopIndex;
                    modalTitle.textContent = "Editar Parada";
                    stopNameInput.value = stop.name;
                    stopTimeInput.value = stop.time;
                    stopModal.classList.remove('hidden');
                }

                if (button.classList.contains('delete-stop-btn')) {
                    if (confirm("¿Estás seguro de que quieres eliminar esta parada?")) {
                        recorridos[recorridoName].splice(stopIndex, 1);
                        saveRecorridosToStorage();
                        updateStopsList(recorridoName);
                        drawRecorridoOnMap(recorridoName);
                    }
                }
            });

            // --- LÓGICA DE SEGUIMIENTO EN TIEMPO REAL ---
            startBtn.addEventListener('click', () => {
                const selectedRecorrido = recorridoSelect.value;
                if (!selectedRecorrido || recorridos[selectedRecorrido].length < 2) {
                    alert("Selecciona un recorrido con al menos 2 paradas para iniciar.");
                    return;
                }
                
                currentRecorrido = { name: selectedRecorrido, stops: recorridos[selectedRecorrido], nextStopIndex: 0 };
                startBtn.disabled = true; stopBtn.disabled = false; recorridoSelect.disabled = true; createRecorridoBtn.disabled = true; deleteRecorridoBtn.disabled = true;
                
                checkRecorridoStatus(null, true);

                if (navigator.geolocation) {
                    gpsInterval = navigator.geolocation.watchPosition(updateDriverPosition, handleLocationError, { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 });
                } else {
                    alert("Geolocalización no es soportada.");
                    stopTracking();
                }
                
                timeUpdateInterval = setInterval(updateTimeDisplay, 1000);
            });
            
            stopBtn.addEventListener('click', stopTracking);

            function stopTracking() {
                if (gpsInterval) navigator.geolocation.clearWatch(gpsInterval);
                if (timeUpdateInterval) clearInterval(timeUpdateInterval);
                currentRecorrido = null; gpsInterval = null; timeUpdateInterval = null; currentDriverLatLng = null;
                startBtn.disabled = false; stopBtn.disabled = true; recorridoSelect.disabled = false; createRecorridoBtn.disabled = false; deleteRecorridoBtn.disabled = false;
                updateStatus('--:--', 'inactive');
                nextStopInfo.textContent = '';
            }

            function updateDriverPosition(position) {
                currentDriverLatLng = L.latLng(position.coords.latitude, position.coords.longitude);
                driverMarker.setLatLng(currentDriverLatLng);
                map.panTo(currentDriverLatLng);
                if (currentRecorrido) checkRecorridoStatus(currentDriverLatLng);
            }

            function checkRecorridoStatus(driverLatLng, isInitialCheck = false) {
                if (!currentRecorrido || currentRecorrido.nextStopIndex >= currentRecorrido.stops.length) return;
                
                if (isInitialCheck) {
                    currentRecorrido.nextStopIndex = 1;
                    nextStopInfo.textContent = `Próxima parada: ${currentRecorrido.stops[1].name}`;
                    return;
                }

                const nextStop = currentRecorrido.stops[currentRecorrido.nextStopIndex];
                if (driverLatLng.distanceTo(L.latLng(nextStop.lat, nextStop.lng)) <= PROXIMITY_THRESHOLD_METERS) {
                    currentRecorrido.nextStopIndex++;
                    if (currentRecorrido.nextStopIndex < currentRecorrido.stops.length) {
                        nextStopInfo.textContent = `Próxima parada: ${currentRecorrido.stops[currentRecorrido.nextStopIndex].name}`;
                    } else {
                        nextStopInfo.textContent = 'Recorrido Finalizado.';
                        updateStatus('FIN', 'ontime');
                        stopTracking();
                    }
                }
            }
            
            function updateTimeDisplay() {
                if (!currentRecorrido || !currentDriverLatLng || currentRecorrido.nextStopIndex >= currentRecorrido.stops.length) return;

                const nextStopIndex = currentRecorrido.nextStopIndex;
                const previousStop = currentRecorrido.stops[nextStopIndex - 1];
                const nextStop = currentRecorrido.stops[nextStopIndex];
                
                const prevStopLatLng = L.latLng(previousStop.lat, previousStop.lng);
                const nextStopLatLng = L.latLng(nextStop.lat, nextStop.lng);
                const totalSegmentDistance = prevStopLatLng.distanceTo(nextStopLatLng);
                const distanceFromPrevStop = currentDriverLatLng.distanceTo(prevStopLatLng);
                
                let progress = totalSegmentDistance > 1 ? distanceFromPrevStop / totalSegmentDistance : 0;
                progress = Math.max(0, Math.min(1, progress));

                const today = new Date();
                const dateString = today.toISOString().split('T')[0];
                const prevScheduledTimeMs = new Date(`${dateString}T${previousStop.time}`).getTime();
                const nextScheduledTimeMs = new Date(`${dateString}T${nextStop.time}`).getTime();
                const totalSegmentTimeMs = nextScheduledTimeMs - prevScheduledTimeMs;
                const expectedTimeAtPositionMs = prevScheduledTimeMs + (totalSegmentTimeMs * progress);
                const deviationMs = today.getTime() - expectedTimeAtPositionMs;

                formatAndDisplayDeviation(deviationMs);
            }
            
            function formatAndDisplayDeviation(deviationMs) {
                const diffSeconds = Math.round(deviationMs / 1000);
                const absDiffSeconds = Math.abs(diffSeconds);
                const displayMinutes = String(Math.floor(absDiffSeconds / 60)).padStart(2, '0');
                const displaySeconds = String(absDiffSeconds % 60).padStart(2, '0');
                let text, statusClass;

                if (diffSeconds > 30) { text = `-${displayMinutes}:${displaySeconds}`; statusClass = 'late'; } 
                else if (diffSeconds < -30) { text = `+${displayMinutes}:${displaySeconds}`; statusClass = 'early'; } 
                else { text = '00:00'; statusClass = 'ontime'; }
                statusIndicator.textContent = text;
                statusIndicator.className = `status-indicator status-${statusClass}`;
            }

            function handleLocationError(error) {
                console.error("Error de Geolocalización: ", error);
                alert(`Error al obtener la ubicación: ${error.message}`);
                stopTracking();
            }

            // --- FUNCIONES DEL MAPA ---
            let recorridoPolyline = null;
            let stopMarkers = [];

            function clearMapLayers() {
                if (recorridoPolyline) map.removeLayer(recorridoPolyline);
                stopMarkers.forEach(marker => map.removeLayer(marker));
                recorridoPolyline = null; stopMarkers = [];
            }

            function drawRecorridoOnMap(recorridoName) {
                clearMapLayers();
                const stops = recorridos[recorridoName];
                if (!stops || stops.length < 1) return;

                const latLngs = stops.map(stop => [stop.lat, stop.lng]);
                recorridoPolyline = L.polyline(latLngs, { color: 'blue' }).addTo(map);
                
                stops.forEach((stop, index) => {
                    const marker = L.marker([stop.lat, stop.lng]).addTo(map).bindPopup(`<b>${index + 1}. ${stop.name}</b><br>Hora: ${stop.time}`);
                    stopMarkers.push(marker);
                });

                if(stops.length > 0) map.fitBounds(recorridoPolyline.getBounds());
            }

            // --- INICIO DE LA APLICACIÓN ---
            initializeMap();
            loadRecorridosFromStorage();
        });
    </script>

</body>
</html>
