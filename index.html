<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Move Pro - Asistente de Conductor</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <style>
        :root {
            --primary-color: #4f46e5; /* indigo-600 */
            --primary-hover: #4338ca; /* indigo-700 */
            --danger-color: #dc2626; /* red-600 */
            --danger-hover: #b91c1c; /* red-700 */
            --success-color: #16a34a; /* green-600 */
            --success-hover: #15803d; /* green-700 */
        }
        #map { height: 400px; width: 100%; cursor: crosshair; border-radius: 0.5rem; }
        .status-indicator {
            font-size: 3rem; font-weight: 800; text-align: center;
            padding: 1.25rem; border-radius: 0.5rem; color: white;
            transition: background-color 0.3s ease;
            letter-spacing: 0.05em;
        }
        .status-ontime { background-color: var(--success-color); }
        .status-late { background-color: var(--danger-color); }
        .status-early { background-color: #2563eb; } /* blue-600 */
        .status-inactive { background-color: #4b5563; } /* gray-600 */
        .stop-item-btn {
            background: none; border: none; cursor: pointer;
            margin-left: 8px; vertical-align: middle;
            transition: color 0.2s;
        }
        .creation-guide {
            background-color: #eef2ff; color: var(--primary-color); border-left: 4px solid var(--primary-color);
            padding: 12px; margin-bottom: 1rem; border-radius: 4px;
            font-weight: 500;
        }
        .btn {
            padding: 0.75rem 1rem; border-radius: 0.375rem; font-weight: 600;
            transition: background-color 0.2s, transform 0.1s;
            display: flex; align-items: center; justify-content: center;
        }
        .btn:active { transform: scale(0.98); }
        .btn-primary { background-color: var(--primary-color); color: white; }
        .btn-primary:hover { background-color: var(--primary-hover); }
        .btn-danger { background-color: var(--danger-color); color: white; }
        .btn-danger:hover { background-color: var(--danger-hover); }
        .btn-success { background-color: var(--success-color); color: white; }
        .btn-success:hover { background-color: var(--success-hover); }
    </style>
</head>
<body class="bg-gray-100 font-sans">

    <div class="container mx-auto p-4 max-w-7xl">

        <header class="bg-white shadow-lg rounded-xl p-6 mb-6 flex justify-between items-center">
            <div>
                <h1 class="text-4xl font-extrabold text-gray-800">Smart Move Pro</h1>
                <p class="text-gray-500 text-lg">Tu asistente de recorrido inteligente</p>
            </div>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-3 gap-6">

            <!-- Columna de Gesti√≥n de Recorrido -->
            <div class="lg:col-span-1 bg-white p-6 rounded-xl shadow-lg">
                <h2 class="text-2xl font-bold mb-4 border-b pb-3 text-gray-700">Gesti√≥n de Recorrido</h2>
                
                <div class="space-y-4">
                    <div>
                        <label for="recorrido-select" class="block text-sm font-medium text-gray-700 mb-1">Seleccionar Recorrido:</label>
                        <div class="flex items-center space-x-2">
                            <select id="recorrido-select" class="w-full p-2 border border-gray-300 rounded-md shadow-sm"></select>
                            <button id="delete-recorrido-btn" title="Eliminar Recorrido" class="p-2.5 btn btn-danger">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clip-rule="evenodd" /></svg>
                            </button>
                        </div>
                    </div>

                    <div id="bandera-select-container" class="mt-4">
                        <label class="block text-sm font-medium text-gray-700 mb-2">Seleccionar Bandera:</label>
                        <div class="flex items-center space-x-4 bg-gray-100 p-2 rounded-lg">
                            <label class="flex-1 text-center p-2 rounded-md cursor-pointer transition-colors has-[:checked]:bg-indigo-600 has-[:checked]:text-white has-[:checked]:shadow-md">
                                <input type="radio" name="bandera" value="ida" id="bandera-ida-radio" checked class="sr-only">
                                <span>Ida</span>
                            </label>
                            <label class="flex-1 text-center p-2 rounded-md cursor-pointer transition-colors has-[:checked]:bg-indigo-600 has-[:checked]:text-white has-[:checked]:shadow-md">
                                <input type="radio" name="bandera" value="vuelta" id="bandera-vuelta-radio" class="sr-only">
                                <span>Vuelta</span>
                            </label>
                        </div>
                    </div>

                    <div class="mt-4">
                        <label for="radius-input" class="block text-sm font-medium text-gray-700 mb-1">Radio de Parada (metros):</label>
                        <input type="number" id="radius-input" value="20" min="5" class="w-full p-2 border border-gray-300 rounded-md shadow-sm">
                    </div>
                    
                    <div class="flex items-center">
                        <input type="checkbox" id="auto-calc-checkbox" class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                        <label for="auto-calc-checkbox" class="ml-2 block text-sm text-gray-900">Calcular horarios intermedios</label>
                    </div>

                    <div class="flex space-x-2 pt-2">
                        <button id="start-btn" class="flex-1 btn btn-success">Iniciar</button>
                        <button id="stop-btn" class="flex-1 btn btn-danger" disabled>Detener</button>
                    </div>
                    <hr class="my-2">
                    <div>
                        <label for="new-recorrido-name" class="block text-sm font-medium text-gray-700 mb-1">Nombre Nuevo Recorrido:</label>
                        <input type="text" id="new-recorrido-name" placeholder="Ej: L√≠nea 106 - Ramal A" class="w-full p-2 border border-gray-300 rounded-md shadow-sm">
                        <button id="create-recorrido-btn" class="mt-2 w-full btn btn-primary">Crear Recorrido</button>
                    </div>
                    <div>
                        <div id="creation-guide-container" class="hidden"></div>
                        <h3 class="text-lg font-bold mb-2 text-gray-700">Puntos del Recorrido</h3>
                        <ul id="stops-list" class="space-y-2 bg-gray-50 p-3 rounded-md h-48 overflow-y-auto"></ul>
                    </div>
                </div>
            </div>

            <!-- Columna de Mapa y Estado -->
            <div class="lg:col-span-2 bg-white p-6 rounded-xl shadow-lg">
                <h2 class="text-2xl font-bold mb-4 border-b pb-3 text-gray-700">Estado y Mapa</h2>
                <div id="status-indicator" class="status-indicator status-inactive mb-2">--:--</div>
                <p id="current-stop-info" class="text-center text-green-600 font-bold h-6 mb-1 text-xl hidden"></p>
                <p id="next-stop-info" class="text-center text-gray-700 font-semibold h-6 mb-4 text-xl"></p>
                <div id="map" class="shadow-inner"></div>
                <p class="text-xs text-gray-500 mt-2 text-center">Haz clic en el mapa para agregar un punto al recorrido activo.</p>
                
                <div id="eta-container" class="mt-6 hidden">
                    <h3 class="text-xl font-bold text-gray-700 mb-3">Tiempos Estimados (Pasajero)</h3>
                    <div class="overflow-x-auto">
                        <table class="min-w-full bg-white border rounded-lg">
                            <thead class="bg-gray-50">
                                <tr>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Parada</th>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Programado</th>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">ETA</th>
                                </tr>
                            </thead>
                            <tbody id="eta-table-body" class="divide-y divide-gray-200">
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Modal para agregar/editar punto -->
    <div id="stop-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full hidden">
        <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
            <div class="mt-3 text-center">
                <h3 id="modal-title" class="text-lg leading-6 font-medium text-gray-900"></h3>
                <div class="mt-2 px-7 py-3 space-y-4">
                    <div id="point-type-container">
                        <label for="point-type-select" class="block text-sm font-medium text-gray-700 mb-1">Tipo de Punto:</label>
                        <select id="point-type-select" class="w-full p-2 border border-gray-300 rounded-md shadow-sm">
                            <option value="stop">Parada</option>
                            <option value="waypoint">Punto de Paso</option>
                        </select>
                    </div>
                    <div id="point-name-container">
                        <input type="text" id="stop-name" placeholder="Nombre (opcional)" class="w-full p-2 border border-gray-300 rounded-md">
                    </div>
                    <div id="datetime-input-container">
                        <label class="text-sm text-gray-600">Fecha y Hora Programada:</label>
                        <div class="flex space-x-2">
                            <input type="date" id="stop-date" class="w-1/2 p-2 border border-gray-300 rounded-md">
                            <input type="time" id="stop-time" class="w-1/2 p-2 border border-gray-300 rounded-md">
                        </div>
                    </div>
                </div>
                <div class="items-center px-4 py-3">
                    <button id="save-stop-btn" class="w-full btn btn-success">Guardar</button>
                    <button id="cancel-stop-btn" class="mt-2 w-full btn bg-gray-500 hover:bg-gray-600 text-white">Cancelar</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- VARIABLES GLOBALES ---
            let map, driverMarker, currentRecorrido, gpsInterval, timeUpdateInterval, tempStopCoords;
            let recorridos = {};
            let currentDriverLatLng = null;
            let editingStopIndex = null;
            let stopRadius = 20;
            let radiusCircles = [];
            let lastDeviationSeconds = 0;
            let currentBandera = 'ida';

            // --- ELEMENTOS DEL DOM ---
            const recorridoSelect = document.getElementById('recorrido-select');
            const startBtn = document.getElementById('start-btn');
            const stopBtn = document.getElementById('stop-btn');
            const createRecorridoBtn = document.getElementById('create-recorrido-btn');
            const newRecorridoNameInput = document.getElementById('new-recorrido-name');
            const deleteRecorridoBtn = document.getElementById('delete-recorrido-btn');
            const radiusInput = document.getElementById('radius-input');
            const autoCalcCheckbox = document.getElementById('auto-calc-checkbox');
            const stopsList = document.getElementById('stops-list');
            const banderaIdaRadio = document.getElementById('bandera-ida-radio');
            const banderaVueltaRadio = document.getElementById('bandera-vuelta-radio');
            const statusIndicator = document.getElementById('status-indicator');
            const currentStopInfo = document.getElementById('current-stop-info');
            const nextStopInfo = document.getElementById('next-stop-info');
            const mapElement = document.getElementById('map');
            const creationGuideContainer = document.getElementById('creation-guide-container');
            const etaContainer = document.getElementById('eta-container');
            const etaTableBody = document.getElementById('eta-table-body');
            
            // Modal
            const stopModal = document.getElementById('stop-modal');
            const modalTitle = document.getElementById('modal-title');
            const saveStopBtn = document.getElementById('save-stop-btn');
            const cancelStopBtn = document.getElementById('cancel-stop-btn');
            const pointTypeContainer = document.getElementById('point-type-container');
            const pointTypeSelect = document.getElementById('point-type-select');
            const pointNameContainer = document.getElementById('point-name-container');
            const stopNameInput = document.getElementById('stop-name');
            const datetimeInputContainer = document.getElementById('datetime-input-container');
            const stopDateInput = document.getElementById('stop-date');
            const stopTimeInput = document.getElementById('stop-time');

            // --- INICIALIZACI√ìN ---
            function initializeMap() {
                map = L.map(mapElement).setView([-27.46, -58.83], 13);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(map);
                const driverIcon = L.icon({
                    iconUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon-2x.png',
                    iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
                });
                driverMarker = L.marker([0, 0], { icon: driverIcon }).addTo(map).bindPopup("Tu posici√≥n");
                map.on('click', onMapClick);
            }

            function loadRecorridosFromStorage() {
                const storedRecorridos = localStorage.getItem('busRecorridos');
                if (storedRecorridos) {
                    let loadedRecorridos = JSON.parse(storedRecorridos);
                    // Migrate old data structure if necessary
                    for (const name in loadedRecorridos) {
                        if (Array.isArray(loadedRecorridos[name])) {
                            console.log(`Migrating old route format for: ${name}`);
                            const oldPath = loadedRecorridos[name];
                            loadedRecorridos[name] = {
                                path: { ida: oldPath, vuelta: [] }
                            };
                        }
                    }
                    recorridos = loadedRecorridos;
                    saveRecorridosToStorage(); // Save back the migrated data
                }
                updateRecorridoSelector();
            }

            function saveRecorridosToStorage() {
                localStorage.setItem('busRecorridos', JSON.stringify(recorridos));
            }

            // --- GESTI√ìN DE RECORRIDOS Y PUNTOS ---
            function updateRecorridoSelector() {
                const currentSelection = recorridoSelect.value;
                recorridoSelect.innerHTML = '<option value="">-- Selecciona un recorrido --</option>';
                for (const recorridoName in recorridos) {
                    const option = document.createElement('option');
                    option.value = recorridoName;
                    option.textContent = recorridoName;
                    recorridoSelect.appendChild(option);
                }
                recorridoSelect.value = currentSelection;
                if (!recorridoSelect.value && Object.keys(recorridos).length > 0) {
                    recorridoSelect.value = Object.keys(recorridos)[0];
                }
                updateUIForSelectedRecorrido();
            }

            function updateUIForSelectedRecorrido() {
                const selectedRecorrido = recorridoSelect.value;
                updateCreationGuide(selectedRecorrido);
                updateStopsList(selectedRecorrido);
                drawRecorridoOnMap(selectedRecorrido);
            }
            
            function formatDateTime(isoString) {
                if (!isoString) return 'N/A';
                // new Date() interpreta correctamente el string ISO (con 'Z') y lo ajusta a la zona horaria local del navegador.
                const date = new Date(isoString);
                const day = String(date.getDate()).padStart(2, '0');
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                return `${day}/${month} ${hours}:${minutes}`;
            }

            function updateStopsList(recorridoName) {
                stopsList.innerHTML = '';
                const recorrido = recorridos[recorridoName];
                if (!recorrido || !recorrido.path) {
                    stopsList.innerHTML = '<li class="text-gray-500">No hay puntos.</li>';
                    return;
                }
                const points = recorrido.path[currentBandera] || [];

                if (points.length === 0) {
                    stopsList.innerHTML = '<li class="text-gray-500">No hay puntos.</li>';
                } else {
                    points.forEach((point, index) => {
                        const li = document.createElement('li');
                        li.className = 'flex justify-between items-center bg-white p-2 rounded-md shadow-sm';
                        const icon = point.type === 'stop' ? 'üÖøÔ∏è' : '‚û°Ô∏è';
                        const name = point.name || (point.type === 'stop' ? `Parada ${index + 1}` : `Punto ${index + 1}`);
                        li.innerHTML = `
                            <span>${icon} ${name}</span>
                            <div>
                                <button title="Editar Punto" class="stop-item-btn edit-stop-btn text-blue-600" data-index="${index}"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M17.414 2.586a2 2 0 00-2.828 0L7 10.172V13h2.828l7.586-7.586a2 2 0 000-2.828z" /><path fill-rule="evenodd" d="M2 6a2 2 0 012-2h4a1 1 0 010 2H4v10h10v-4a1 1 0 112 0v4a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" clip-rule="evenodd" /></svg></button>
                                <button title="Eliminar Punto" class="stop-item-btn delete-stop-btn text-red-600" data-index="${index}"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clip-rule="evenodd" /></svg></button>
                            </div>`;
                        stopsList.appendChild(li);
                    });
                }
            }

            function updateCreationGuide(recorridoName) {
                const recorrido = recorridos[recorridoName];
                const points = (recorrido && recorrido.path) ? (recorrido.path[currentBandera] || []) : [];
                let guideText = '';
                if (recorridoName) {
                    if (points.length === 0) {
                        guideText = '1. Haz clic en el mapa para a√±adir la <b>primera parada</b>.';
                    } else if (points.length === 1) {
                        guideText = '2. Haz clic para a√±adir la <b>√∫ltima parada</b>.';
                    } else {
                        guideText = '3. A√±ade <b>puntos intermedios</b> o inicia el recorrido.';
                    }
                }
                if (guideText) {
                    creationGuideContainer.innerHTML = `<div class="creation-guide">${guideText}</div>`;
                    creationGuideContainer.classList.remove('hidden');
                } else {
                    creationGuideContainer.classList.add('hidden');
                }
            }

            createRecorridoBtn.addEventListener('click', () => {
                const recorridoName = newRecorridoNameInput.value.trim();
                if (recorridoName && !recorridos[recorridoName]) {
                    recorridos[recorridoName] = { path: { ida: [], vuelta: [] } };
                    saveRecorridosToStorage();
                    newRecorridoNameInput.value = '';
                    updateRecorridoSelector();
                    recorridoSelect.value = recorridoName;
                } else {
                    alert(recorridos[recorridoName] ? 'Error: Ya existe un recorrido con ese nombre.' : 'Error: Ingresa un nombre v√°lido.');
                }
            });

            deleteRecorridoBtn.addEventListener('click', () => {
                const recorridoName = recorridoSelect.value;
                if (!recorridoName) return;
                if (confirm(`¬øEst√°s seguro de que quieres eliminar el recorrido "${recorridoName}"?`)) {
                    delete recorridos[recorridoName];
                    saveRecorridosToStorage();
                    recorridoSelect.value = '';
                    updateRecorridoSelector();
                }
            });

            recorridoSelect.addEventListener('change', updateUIForSelectedRecorrido);

            banderaIdaRadio.addEventListener('change', () => {
                currentBandera = 'ida';
                updateUIForSelectedRecorrido();
            });

            banderaVueltaRadio.addEventListener('change', () => {
                currentBandera = 'vuelta';
                updateUIForSelectedRecorrido();
            });

            radiusInput.addEventListener('change', () => {
                stopRadius = parseInt(radiusInput.value) || 20;
                drawRecorridoOnMap(recorridoSelect.value);
            });
            autoCalcCheckbox.addEventListener('change', () => {
                if (autoCalcCheckbox.checked) {
                    calculateIntermediateTimes(recorridoSelect.value);
                }
                updateUIForSelectedRecorrido();
            });

            function onMapClick(e) {
                const selectedRecorrido = recorridoSelect.value;
                if (!selectedRecorrido || !recorridos[selectedRecorrido].path) {
                    alert("Por favor, crea o selecciona un recorrido primero.");
                    return;
                }
                tempStopCoords = e.latlng;
                editingStopIndex = null;
                const points = recorridos[selectedRecorrido].path[currentBandera];

                // Simplified logic for the modal title
                if (points.length < 2) {
                    modalTitle.textContent = points.length === 0 ? "Definir Primera Parada" : "Definir √öltima Parada";
                    pointTypeContainer.style.display = 'none';
                } else {
                    modalTitle.textContent = "A√±adir Punto Intermedio";
                    pointTypeContainer.style.display = 'block';
                }
                datetimeInputContainer.style.display = 'none'; // Always hide time inputs now
                
                pointTypeSelect.value = 'stop';
                stopNameInput.value = '';
                stopModal.classList.remove('hidden');
            }
            
            pointTypeSelect.addEventListener('change', toggleNameForWaypoint);
            function toggleNameForWaypoint() {
                pointNameContainer.style.display = pointTypeSelect.value === 'waypoint' ? 'none' : 'block';
            }

            saveStopBtn.addEventListener('click', () => {
                const stopName = stopNameInput.value.trim();
                const pointType = pointTypeSelect.value;
                const selectedRecorrido = recorridoSelect.value;
                const points = recorridos[selectedRecorrido].path[currentBandera];

                if (editingStopIndex !== null) {
                    const pointToEdit = points[editingStopIndex];
                    pointToEdit.name = stopName;
                    pointToEdit.type = pointType;
                } else {
                    const newPoint = { name: stopName, type: pointType, lat: tempStopCoords.lat, lng: tempStopCoords.lng };
                    if (points.length < 2) {
                        points.push(newPoint);
                    } else {
                        points.splice(points.length - 1, 0, newPoint);
                    }
                }
                
                // The concept of auto-calculating times is now deferred to timetable generation
                // if (autoCalcCheckbox.checked) {
                //     calculateIntermediateTimes(selectedRecorrido);
                // }

                saveRecorridosToStorage();
                updateUIForSelectedRecorrido();
                stopModal.classList.add('hidden');
                editingStopIndex = null;
            });

            cancelStopBtn.addEventListener('click', () => {
                stopModal.classList.add('hidden');
                editingStopIndex = null;
            });

            // CORRECCI√ìN: L√≥gica para editar paradas
            stopsList.addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if (!button) return;
                const recorridoName = recorridoSelect.value;
                if (!recorridoName) return;
                const stopIndex = parseInt(button.dataset.index);

                if (button.classList.contains('edit-stop-btn')) {
                    editingStopIndex = stopIndex;
                    const point = recorridos[recorridoName].path[currentBandera][stopIndex];
                    modalTitle.textContent = "Editar Punto";
                    stopNameInput.value = point.name || '';
                    pointTypeSelect.value = point.type || 'stop';
                    
                    const points = recorridos[recorridoName].path[currentBandera];
                    const isFirstOrLast = stopIndex === 0 || stopIndex === (points.length - 1);

                    datetimeInputContainer.style.display = 'none'; // Always hide
                    pointTypeContainer.style.display = (isFirstOrLast) ? 'none' : 'block';
                    toggleNameForWaypoint();
                    stopModal.classList.remove('hidden');
                }
                
                if (button.classList.contains('delete-stop-btn')) {
                    if (confirm("¬øEst√°s seguro de que quieres eliminar este punto?")) {
                        recorridos[recorridoName].path[currentBandera].splice(stopIndex, 1);
                        // auto-calc times is deferred
                        // if (autoCalcCheckbox.checked) calculateIntermediateTimes(recorridoName);
                        saveRecorridosToStorage();
                        updateUIForSelectedRecorrido();
                    }
                }
            });

            // CORREGIDO Y REESCRITO: L√≥gica de c√°lculo de horarios intermedios
            function calculateIntermediateTimes(recorridoName) {
                const points = recorridos[recorridoName];
                if (!points || points.length < 2) return;

                const firstPoint = points[0];
                const lastPoint = points[points.length - 1];

                if (!firstPoint.dateTime || !lastPoint.dateTime) {
                    console.error("No se pueden calcular los tiempos intermedios sin una hora de inicio y fin.");
                    return;
                }

                const startTime = new Date(firstPoint.dateTime).getTime();
                const endTime = new Date(lastPoint.dateTime).getTime();
                const totalDurationMs = endTime - startTime;

                if (totalDurationMs <= 0) {
                    console.warn("La duraci√≥n total es cero o negativa. No se pueden interpolar los tiempos.");
                    // Limpiar los tiempos intermedios si la duraci√≥n es inv√°lida.
                    for (let i = 1; i < points.length - 1; i++) {
                        points[i].dateTime = null;
                    }
                    saveRecorridosToStorage();
                    return;
                }

                // 1. Calcular la distancia total del recorrido siguiendo todos los puntos.
                const segmentDistances = points.map((point, i) => {
                    if (i === points.length - 1) return 0; // El √∫ltimo punto no tiene segmento siguiente.
                    const from = L.latLng(point.lat, point.lng);
                    const to = L.latLng(points[i+1].lat, points[i+1].lng);
                    return from.distanceTo(to);
                });
                const totalDistance = segmentDistances.reduce((sum, dist) => sum + dist, 0);

                if (totalDistance === 0) {
                    console.warn("La distancia total es cero. Distribuyendo el tiempo de manera uniforme.");
                    const timeSlice = totalDurationMs / (points.length - 1);
                     for (let i = 1; i < points.length - 1; i++) {
                        const pointTimeMs = startTime + (timeSlice * i);
                        points[i].dateTime = new Date(pointTimeMs).toISOString();
                    }
                    saveRecorridosToStorage();
                    return;
                }

                // 2. Calcular el tiempo para cada punto intermedio basado en su progreso a lo largo de la distancia total.
                let cumulativeDistance = 0;
                for (let i = 1; i < points.length - 1; i++) {
                    cumulativeDistance += segmentDistances[i-1];
                    
                    const progress = cumulativeDistance / totalDistance;
                    const pointTimeMs = startTime + (totalDurationMs * progress);
                    
                    // CORRECCI√ìN CLAVE: Usar toISOString() completo para preservar la informaci√≥n de zona horaria (UTC).
                    // Al mantener la 'Z' al final, se asegura que la fecha se interprete consistentemente
                    // como UTC en todas partes, y las funciones como .getHours() la convertir√°n correctamente a la hora local para visualizaci√≥n.
                    points[i].dateTime = new Date(pointTimeMs).toISOString();
                }

                saveRecorridosToStorage();
            }


            // --- L√ìGICA DE SEGUIMIENTO EN TIEMPO REAL ---
            startBtn.addEventListener('click', () => {
                const selectedRecorridoName = recorridoSelect.value;
                const recorrido = recorridos[selectedRecorridoName];
                if (!selectedRecorridoName || !recorrido || !recorrido.path) {
                    alert("Selecciona un recorrido v√°lido.");
                    return;
                }

                const stops = recorrido.path[currentBandera];
                if (stops.length < 2) {
                    alert("La bandera seleccionada debe tener al menos 2 puntos para iniciar.");
                    return;
                }

                // For now, tracking will just use the selected bandera path.
                // The full timetable/lap selection will be implemented later.
                currentRecorrido = { name: selectedRecorridoName, stops: stops, lastVisitedStopIndex: -1, currentTargetIndex: 0, trace: [] };
                startBtn.disabled = true; stopBtn.disabled = false; recorridoSelect.disabled = true; createRecorridoBtn.disabled = true; deleteRecorridoBtn.disabled = true; radiusInput.disabled = true; autoCalcCheckbox.disabled = true;
                
                etaContainer.classList.remove('hidden');

                if (navigator.geolocation) {
                    gpsInterval = navigator.geolocation.watchPosition(updateDriverPosition, handleLocationError, { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 });
                } else {
                    alert("Geolocalizaci√≥n no es soportada.");
                    stopTracking();
                }
                timeUpdateInterval = setInterval(updateTimeDisplay, 1000);
            });
            
            stopBtn.addEventListener('click', stopTracking);

            function stopTracking() {
                if (gpsInterval) navigator.geolocation.clearWatch(gpsInterval);
                if (timeUpdateInterval) clearInterval(timeUpdateInterval);
                currentRecorrido = null; gpsInterval = null; timeUpdateInterval = null; currentDriverLatLng = null;
                startBtn.disabled = false; stopBtn.disabled = true; recorridoSelect.disabled = false; createRecorridoBtn.disabled = false; deleteRecorridoBtn.disabled = false; radiusInput.disabled = false; autoCalcCheckbox.disabled = false;
                updateStatus('--:--', 'inactive');
                nextStopInfo.textContent = '';
                currentStopInfo.classList.add('hidden');
                currentStopInfo.textContent = '';
                etaContainer.classList.add('hidden');
            }

            function updateDriverPosition(position) {
                currentDriverLatLng = L.latLng(position.coords.latitude, position.coords.longitude);
                driverMarker.setLatLng(currentDriverLatLng);
                if (currentRecorrido) {
                    currentRecorrido.trace.push(currentDriverLatLng);
                    checkRecorridoStatus(currentDriverLatLng);
                }
            }

            function checkRecorridoStatus(driverLatLng) {
                if (!currentRecorrido) return;

                let inRadiusOfAnyStop = null;
                for (let i = 0; i < currentRecorrido.stops.length; i++) {
                    const stop = currentRecorrido.stops[i];
                    if (stop.type === 'stop' && driverLatLng.distanceTo(L.latLng(stop.lat, stop.lng)) <= stopRadius) {
                        inRadiusOfAnyStop = { stop: stop, index: i };
                        break;
                    }
                }

                if (inRadiusOfAnyStop) {
                    currentStopInfo.textContent = `PARADA ACTUAL: ${inRadiusOfAnyStop.stop.name || `Parada ${inRadiusOfAnyStop.index + 1}`}`;
                    currentStopInfo.classList.remove('hidden');
                    if (inRadiusOfAnyStop.index > currentRecorrido.lastVisitedStopIndex) {
                        currentRecorrido.lastVisitedStopIndex = inRadiusOfAnyStop.index;
                    }
                } else {
                    currentStopInfo.classList.add('hidden');
                }

                const nextIndex = currentRecorrido.lastVisitedStopIndex + 1;

                if (nextIndex >= currentRecorrido.stops.length) {
                    nextStopInfo.textContent = 'Recorrido Finalizado.';
                    updateStatus('FIN', 'ontime');
                    stopTracking();
                    return;
                }
                currentRecorrido.currentTargetIndex = nextIndex;

                let nextDisplayStopIndex = currentRecorrido.lastVisitedStopIndex + 1;
                while(nextDisplayStopIndex < currentRecorrido.stops.length && currentRecorrido.stops[nextDisplayStopIndex].type !== 'stop') {
                    nextDisplayStopIndex++;
                }

                if (nextDisplayStopIndex < currentRecorrido.stops.length) {
                    const nextDisplayStop = currentRecorrido.stops[nextDisplayStopIndex];
                    nextStopInfo.textContent = `PR√ìXIMA PARADA: ${nextDisplayStop.name || `Parada ${nextDisplayStopIndex + 1}`}`;
                } else {
                    nextStopInfo.textContent = '√öltima parada como objetivo.';
                }
            }
            
            function updateTimeDisplay() {
                if (!currentRecorrido || !currentDriverLatLng || currentRecorrido.currentTargetIndex === -1) return;
                
                const targetPoint = currentRecorrido.stops[currentRecorrido.currentTargetIndex];
                const prevIndex = currentRecorrido.lastVisitedStopIndex;

                let deviationMs;
                if (prevIndex < 0) {
                    if (!targetPoint.dateTime) return;
                    const scheduledTimeMs = new Date(targetPoint.dateTime).getTime();
                    deviationMs = new Date().getTime() - scheduledTimeMs;
                } else {
                    const previousPoint = currentRecorrido.stops[prevIndex];
                    if (!previousPoint.dateTime || !targetPoint.dateTime) return;

                    const prevPointLatLng = L.latLng(previousPoint.lat, previousPoint.lng);
                    const targetPointLatLng = L.latLng(targetPoint.lat, targetPoint.lng);
                    const totalSegmentDistance = prevPointLatLng.distanceTo(targetPointLatLng);
                    const distanceFromPrevPoint = currentDriverLatLng.distanceTo(prevPointLatLng);
                    let progress = totalSegmentDistance > 0 ? distanceFromPrevPoint / totalSegmentDistance : 0;
                    progress = Math.max(0, Math.min(1, progress));
                    const prevScheduledTimeMs = new Date(previousPoint.dateTime).getTime();
                    const nextScheduledTimeMs = new Date(targetPoint.dateTime).getTime();
                    const totalSegmentTimeMs = nextScheduledTimeMs - prevScheduledTimeMs;
                    if (totalSegmentTimeMs < 0) { console.error("Error: Duraci√≥n de segmento negativa."); return; }
                    const expectedTimeAtPositionMs = prevScheduledTimeMs + (totalSegmentTimeMs * progress);
                    deviationMs = new Date().getTime() - expectedTimeAtPositionMs;
                }

                formatAndDisplayDeviation(deviationMs);
                updateEtaTable();
            }
            
            function formatAndDisplayDeviation(deviationMs) {
                lastDeviationSeconds = Math.round(deviationMs / 1000);
                const absDiffSeconds = Math.abs(lastDeviationSeconds);
                const displayMinutes = String(Math.floor(absDiffSeconds / 60)).padStart(2, '0');
                const displaySeconds = String(absDiffSeconds % 60).padStart(2, '0');
                
                const text = lastDeviationSeconds >= 0 ? `-${displayMinutes}:${displaySeconds}` : `+${displayMinutes}:${displaySeconds}`;
                
                let statusClass;
                if (lastDeviationSeconds > 30) statusClass = 'late';
                else if (lastDeviationSeconds < -30) statusClass = 'early';
                else statusClass = 'ontime';
                
                statusIndicator.textContent = text;
                statusIndicator.className = `status-indicator status-${statusClass}`;
            }

            function updateEtaTable() {
                if (!currentRecorrido) return;
                etaTableBody.innerHTML = '';
                const now = new Date();
                
                const hasLeftFirstStop = currentRecorrido.lastVisitedStopIndex >= 0;

                for (let i = currentRecorrido.lastVisitedStopIndex + 1; i < currentRecorrido.stops.length; i++) {
                    const stop = currentRecorrido.stops[i];
                    if (stop.type === 'stop' && stop.dateTime) {
                        const scheduledTime = new Date(stop.dateTime);
                        const etaBaseSeconds = (scheduledTime - now) / 1000;
                        
                        let finalEtaSeconds;
                        const isEarly = lastDeviationSeconds < 0;
                        const hasStarted = currentRecorrido.lastVisitedStopIndex >= 0;

                        if (isEarly && !hasStarted) {
                            // Case: Early and not started ("haciendo hora"). Ignore deviation.
                            finalEtaSeconds = etaBaseSeconds;
                        } else {
                            // All other cases: Late (anytime) or Early-and-Started. Apply deviation.
                            finalEtaSeconds = etaBaseSeconds + lastDeviationSeconds;
                        }

                        let displayEta;
                        if (finalEtaSeconds <= 59) {
                            displayEta = "ARRIBANDO";
                        } else {
                            displayEta = `${Math.floor(finalEtaSeconds / 60)} min.`;
                        }
                        
                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td class="px-4 py-3 whitespace-nowrap">${stop.name || `Parada ${i + 1}`}</td>
                            <td class="px-4 py-3 whitespace-nowrap">${formatDateTime(stop.dateTime)}</td>
                            <td class="px-4 py-3 whitespace-nowrap font-bold">${displayEta}</td>
                        `;
                        etaTableBody.appendChild(row);
                    }
                }
            }

            function handleLocationError(error) {
                console.error("Error de Geolocalizaci√≥n: ", error);
                alert(`Error al obtener la ubicaci√≥n: ${error.message}`);
                stopTracking();
            }

            // --- FUNCIONES DEL MAPA ---
            let recorridoPolyline = null;
            let stopMarkers = [];

            function clearMapLayers() {
                if (recorridoPolyline) map.removeLayer(recorridoPolyline);
                stopMarkers.forEach(marker => map.removeLayer(marker));
                radiusCircles.forEach(circle => map.removeLayer(circle));
                recorridoPolyline = null; stopMarkers = []; radiusCircles = [];
            }

            function drawRecorridoOnMap(recorridoName) {
                clearMapLayers();
                const recorrido = recorridos[recorridoName];
                if (!recorrido || !recorrido.path) return;

                const stops = recorrido.path[currentBandera];
                if (!stops || stops.length < 1) return;
                const latLngs = stops.map(stop => [stop.lat, stop.lng]);
                recorridoPolyline = L.polyline(latLngs, { color: 'blue' }).addTo(map);
                stops.forEach((stop, index) => {
                    let marker;
                    const name = stop.name || (stop.type === 'stop' ? `Parada ${index + 1}` : `Punto ${index + 1}`);
                    if (stop.type === 'stop') {
                        marker = L.marker([stop.lat, stop.lng]).addTo(map).bindPopup(`<b>Parada: ${name}</b><br>Hora: ${formatDateTime(stop.dateTime)}`);
                        const circle = L.circle([stop.lat, stop.lng], { radius: stopRadius, color: '#16a34a', fillColor: '#22c55e', fillOpacity: 0.2, weight: 1 }).addTo(map);
                        radiusCircles.push(circle);
                    } else { // waypoint
                        marker = L.circleMarker([stop.lat, stop.lng], { radius: 5, color: 'gray', fillColor: '#6b7280', fillOpacity: 1 }).addTo(map).bindPopup(`<b>Punto de Paso: ${name}</b><br>Hora: ${formatDateTime(stop.dateTime)}`);
                    }
                    stopMarkers.push(marker);
                });
                if(stops.length > 0) map.fitBounds(recorridoPolyline.getBounds());
            }

            // --- INICIO DE LA APLICACI√ìN ---
            initializeMap();
            loadRecorridosFromStorage();
        });
    </script>

</body>
</html>
