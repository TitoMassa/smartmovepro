<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Move Pro - Asistente de Conductor</title>
    
    <!-- Tailwind CSS para un diseño moderno y responsivo -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Leaflet.js para el mapa interactivo -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <style>
        /* Estilos adicionales para asegurar que el mapa ocupe el espacio necesario */
        #map { 
            height: 400px; 
            width: 100%;
        }
        /* Estilo para el indicador de estado (adelantado/atrasado) */
        .status-indicator {
            font-size: 2.5rem;
            font-weight: bold;
            text-align: center;
            padding: 20px;
            border-radius: 10px;
            color: white;
            transition: background-color 0.3s ease;
        }
        .status-ontime { background-color: #22c55e; } /* green-500 */
        .status-late { background-color: #ef4444; } /* red-500 */
        .status-early { background-color: #3b82f6; } /* blue-500 */
        .status-inactive { background-color: #6b7280; } /* gray-500 */
    </style>
</head>
<body class="bg-gray-100 font-sans">

    <div class="container mx-auto p-4 max-w-4xl">

        <header class="bg-white shadow-md rounded-lg p-4 mb-6">
            <h1 class="text-3xl font-bold text-gray-800">Smart Move Pro</h1>
            <p class="text-gray-600">Tu asistente de ruta en tiempo real.</p>
        </header>

        <main class="grid grid-cols-1 md:grid-cols-3 gap-6">

            <!-- Columna de Gestión de Ruta -->
            <div class="md:col-span-1 bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Gestión de Ruta</h2>
                
                <!-- Selección de Ruta -->
                <div class="mb-4">
                    <label for="route-select" class="block text-sm font-medium text-gray-700 mb-1">Seleccionar Ruta:</label>
                    <select id="route-select" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"></select>
                </div>

                <!-- Botones de Acción -->
                <div class="flex space-x-2 mb-4">
                    <button id="start-route-btn" class="flex-1 bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-md transition">Iniciar</button>
                    <button id="stop-route-btn" class="flex-1 bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-md transition" disabled>Detener</button>
                </div>
                
                <hr class="my-4">

                <!-- Creación de Nueva Ruta -->
                <div class="mb-4">
                    <label for="new-route-name" class="block text-sm font-medium text-gray-700 mb-1">Nombre Nueva Ruta:</label>
                    <input type="text" id="new-route-name" placeholder="Ej: Línea 106 - Ramal A" class="w-full p-2 border border-gray-300 rounded-md shadow-sm">
                    <button id="create-route-btn" class="mt-2 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md transition">Crear Ruta</button>
                </div>
                
                <!-- Lista de Paradas -->
                <div>
                    <h3 class="text-lg font-semibold mb-2">Paradas de la Ruta Activa</h3>
                    <ul id="stops-list" class="list-decimal list-inside bg-gray-50 p-3 rounded-md h-48 overflow-y-auto">
                        <!-- Las paradas se agregarán aquí dinámicamente -->
                    </ul>
                </div>
            </div>

            <!-- Columna de Mapa y Estado -->
            <div class="md:col-span-2 bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Estado y Mapa</h2>
                
                <!-- Indicador de Desvío Horario -->
                <div id="status-indicator" class="status-indicator status-inactive mb-4">
                    --:--
                </div>

                <!-- Mapa -->
                <div id="map" class="rounded-lg border border-gray-300"></div>
                <p class="text-xs text-gray-500 mt-1 text-center">Haz clic en el mapa para agregar una parada a la ruta activa.</p>
            </div>

        </main>
    </div>

    <!-- Modal para agregar parada -->
    <div id="add-stop-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full hidden">
        <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
            <div class="mt-3 text-center">
                <h3 class="text-lg leading-6 font-medium text-gray-900">Agregar Nueva Parada</h3>
                <div class="mt-2 px-7 py-3">
                    <input type="text" id="stop-name" placeholder="Nombre de la parada" class="w-full p-2 border border-gray-300 rounded-md mb-3">
                    <label for="stop-time" class="text-sm text-gray-600">Hora programada:</label>
                    <input type="time" id="stop-time" class="w-full p-2 border border-gray-300 rounded-md">
                </div>
                <div class="items-center px-4 py-3">
                    <button id="save-stop-btn" class="px-4 py-2 bg-green-500 text-white text-base font-medium rounded-md w-full shadow-sm hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-300">
                        Guardar Parada
                    </button>
                    <button id="cancel-stop-btn" class="mt-2 px-4 py-2 bg-gray-500 text-white text-base font-medium rounded-md w-full shadow-sm hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-300">
                        Cancelar
                    </button>
                </div>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- VARIABLES GLOBALES ---
            let map;
            let driverMarker;
            let currentRoute = null;
            let routeInterval = null;
            let routes = {}; // { "routeName": [{ name, time, lat, lng }, ...] }
            let tempStopCoords = null;

            const PROXIMITY_THRESHOLD_METERS = 50; // Distancia para considerar que se llegó a una parada

            // --- ELEMENTOS DEL DOM ---
            const routeSelect = document.getElementById('route-select');
            const startBtn = document.getElementById('start-route-btn');
            const stopBtn = document.getElementById('stop-route-btn');
            const createRouteBtn = document.getElementById('create-route-btn');
            const newRouteNameInput = document.getElementById('new-route-name');
            const stopsList = document.getElementById('stops-list');
            const statusIndicator = document.getElementById('status-indicator');
            const mapElement = document.getElementById('map');
            
            // Modal
            const addStopModal = document.getElementById('add-stop-modal');
            const saveStopBtn = document.getElementById('save-stop-btn');
            const cancelStopBtn = document.getElementById('cancel-stop-btn');
            const stopNameInput = document.getElementById('stop-name');
            const stopTimeInput = document.getElementById('stop-time');

            // --- INICIALIZACIÓN ---

            function initializeMap() {
                // Coordenadas iniciales (ej. centro de una ciudad)
                map = L.map(mapElement).setView([-27.46, -58.83], 13);

                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(map);

                // Icono personalizado para el conductor
                const driverIcon = L.icon({
                    iconUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon-2x.png',
                    iconSize: [25, 41],
                    iconAnchor: [12, 41],
                    popupAnchor: [1, -34],
                    shadowSize: [41, 41]
                });
                driverMarker = L.marker([0, 0], { icon: driverIcon }).addTo(map).bindPopup("Tu posición");

                // Evento para agregar paradas al hacer clic en el mapa
                map.on('click', onMapClick);
            }

            function loadRoutesFromStorage() {
                const storedRoutes = localStorage.getItem('busRoutes');
                if (storedRoutes) {
                    routes = JSON.parse(storedRoutes);
                }
                updateRouteSelector();
            }

            function saveRoutesToStorage() {
                localStorage.setItem('busRoutes', JSON.stringify(routes));
            }

            // --- GESTIÓN DE RUTAS Y PARADAS ---

            function updateRouteSelector() {
                routeSelect.innerHTML = '<option value="">-- Selecciona una ruta --</option>';
                for (const routeName in routes) {
                    const option = document.createElement('option');
                    option.value = routeName;
                    option.textContent = routeName;
                    routeSelect.appendChild(option);
                }
            }
            
            function updateStopsList(routeName) {
                stopsList.innerHTML = '';
                const stops = routes[routeName] || [];
                if (stops.length === 0) {
                    stopsList.innerHTML = '<li class="text-gray-500">No hay paradas en esta ruta.</li>';
                } else {
                    stops.forEach(stop => {
                        const li = document.createElement('li');
                        li.textContent = `${stop.name} - ${stop.time}`;
                        stopsList.appendChild(li);
                    });
                }
            }

            createRouteBtn.addEventListener('click', () => {
                const routeName = newRouteNameInput.value.trim();
                if (routeName && !routes[routeName]) {
                    routes[routeName] = [];
                    saveRoutesToStorage();
                    updateRouteSelector();
                    newRouteNameInput.value = '';
                    routeSelect.value = routeName; // Seleccionar la nueva ruta
                    updateStopsList(routeName);
                    alert(`Ruta "${routeName}" creada.`);
                } else if (routes[routeName]) {
                    alert('Error: Ya existe una ruta con ese nombre.');
                } else {
                    alert('Error: Ingresa un nombre válido para la ruta.');
                }
            });

            routeSelect.addEventListener('change', () => {
                const selectedRoute = routeSelect.value;
                if (selectedRoute) {
                    updateStopsList(selectedRoute);
                    drawRouteOnMap(selectedRoute);
                } else {
                    stopsList.innerHTML = '';
                    clearMapLayers();
                }
            });

            function onMapClick(e) {
                const selectedRoute = routeSelect.value;
                if (!selectedRoute) {
                    alert("Por favor, selecciona o crea una ruta antes de añadir paradas.");
                    return;
                }
                tempStopCoords = e.latlng;
                stopNameInput.value = '';
                stopTimeInput.value = '';
                addStopModal.classList.remove('hidden');
            }

            saveStopBtn.addEventListener('click', () => {
                const stopName = stopNameInput.value.trim();
                const stopTime = stopTimeInput.value;
                const selectedRoute = routeSelect.value;

                if (stopName && stopTime && tempStopCoords && selectedRoute) {
                    const newStop = {
                        name: stopName,
                        time: stopTime,
                        lat: tempStopCoords.lat,
                        lng: tempStopCoords.lng
                    };
                    
                    routes[selectedRoute].push(newStop);
                    // Reordenar paradas por hora
                    routes[selectedRoute].sort((a, b) => a.time.localeCompare(b.time));
                    
                    saveRoutesToStorage();
                    updateStopsList(selectedRoute);
                    drawRouteOnMap(selectedRoute);

                    addStopModal.classList.add('hidden');
                    tempStopCoords = null;
                } else {
                    alert("Por favor, completa todos los campos.");
                }
            });

            cancelStopBtn.addEventListener('click', () => {
                addStopModal.classList.add('hidden');
                tempStopCoords = null;
            });

            // --- LÓGICA DE SEGUIMIENTO EN TIEMPO REAL ---

            startBtn.addEventListener('click', () => {
                const selectedRoute = routeSelect.value;
                if (!selectedRoute || routes[selectedRoute].length === 0) {
                    alert("Selecciona una ruta con paradas para iniciar.");
                    return;
                }
                
                currentRoute = {
                    name: selectedRoute,
                    stops: routes[selectedRoute],
                    nextStopIndex: 0
                };
                
                startBtn.disabled = true;
                stopBtn.disabled = false;
                routeSelect.disabled = true;
                createRouteBtn.disabled = true;

                if (navigator.geolocation) {
                    routeInterval = navigator.geolocation.watchPosition(
                        updateDriverPosition, 
                        handleLocationError, 
                        { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
                    );
                } else {
                    alert("Geolocalización no es soportada por este navegador.");
                    stopTracking();
                }
            });
            
            stopBtn.addEventListener('click', stopTracking);

            function stopTracking() {
                if (routeInterval) {
                    navigator.geolocation.clearWatch(routeInterval);
                }
                currentRoute = null;
                routeInterval = null;
                startBtn.disabled = false;
                stopBtn.disabled = true;
                routeSelect.disabled = false;
                createRouteBtn.disabled = false;
                updateStatus('--:--', 'inactive');
            }

            function updateDriverPosition(position) {
                const { latitude, longitude } = position.coords;
                const driverLatLng = L.latLng(latitude, longitude);

                // Actualizar marcador del conductor
                driverMarker.setLatLng(driverLatLng);
                map.panTo(driverLatLng);

                if (currentRoute) {
                    checkRouteStatus(driverLatLng);
                }
            }

            function checkRouteStatus(driverLatLng) {
                if (!currentRoute || currentRoute.nextStopIndex >= currentRoute.stops.length) {
                    updateStatus('Ruta Finalizada', 'ontime');
                    stopTracking();
                    return;
                }

                const nextStop = currentRoute.stops[currentRoute.nextStopIndex];
                const distanceToNextStop = driverLatLng.distanceTo(L.latLng(nextStop.lat, nextStop.lng));

                // Si está cerca de la parada, calcula el desvío y avanza a la siguiente
                if (distanceToNextStop <= PROXIMITY_THRESHOLD_METERS) {
                    calculateTimeDifference(nextStop.time);
                    currentRoute.nextStopIndex++;
                } else {
                    // Si no está cerca, podría mostrar la distancia a la próxima parada (opcional)
                    // Por ahora, solo actualizamos el estado si estamos en la parada.
                    // Podríamos mostrar un estado "En camino"
                    const nextStopName = currentRoute.stops[currentRoute.nextStopIndex].name;
                    updateStatus(`Hacia: ${nextStopName}`, 'inactive');
                }
            }

            function calculateTimeDifference(scheduledTimeStr) {
                const now = new Date();
                
                const [hours, minutes] = scheduledTimeStr.split(':');
                const scheduledTime = new Date();
                scheduledTime.setHours(hours);
                scheduledTime.setMinutes(minutes);
                scheduledTime.setSeconds(0);
                scheduledTime.setMilliseconds(0);

                const diffSeconds = Math.round((now - scheduledTime) / 1000);
                
                const absDiffSeconds = Math.abs(diffSeconds);
                const displayMinutes = String(Math.floor(absDiffSeconds / 60)).padStart(2, '0');
                const displaySeconds = String(absDiffSeconds % 60).padStart(2, '0');

                if (diffSeconds > 0) { // Atrasado (la hora actual es mayor a la programada)
                    updateStatus(`-${displayMinutes}:${displaySeconds}`, 'late');
                } else if (diffSeconds < 0) { // Adelantado
                    updateStatus(`+${displayMinutes}:${displaySeconds}`, 'early');
                } else { // Justo a tiempo
                    updateStatus('00:00', 'ontime');
                }
            }

            function updateStatus(text, statusClass) {
                statusIndicator.textContent = text;
                statusIndicator.className = `status-indicator status-${statusClass}`;
            }

            function handleLocationError(error) {
                console.error("Error de Geolocalización: ", error);
                alert(`Error al obtener la ubicación: ${error.message}`);
                stopTracking();
            }

            // --- FUNCIONES DEL MAPA ---
            let routePolyline = null;
            let stopMarkers = [];

            function clearMapLayers() {
                if (routePolyline) {
                    map.removeLayer(routePolyline);
                    routePolyline = null;
                }
                stopMarkers.forEach(marker => map.removeLayer(marker));
                stopMarkers = [];
            }

            function drawRouteOnMap(routeName) {
                clearMapLayers();
                const stops = routes[routeName];
                if (!stops || stops.length < 1) return;

                const latLngs = stops.map(stop => [stop.lat, stop.lng]);
                
                // Dibujar línea de ruta
                routePolyline = L.polyline(latLngs, { color: 'blue' }).addTo(map);
                
                // Dibujar marcadores de parada
                stops.forEach((stop, index) => {
                    const marker = L.marker([stop.lat, stop.lng])
                        .addTo(map)
                        .bindPopup(`<b>${index + 1}. ${stop.name}</b><br>Hora: ${stop.time}`);
                    stopMarkers.push(marker);
                });

                // Ajustar el zoom del mapa para que se vea toda la ruta
                if(stops.length > 0) {
                    map.fitBounds(routePolyline.getBounds());
                }
            }


            // --- INICIO DE LA APLICACIÓN ---
            initializeMap();
            loadRoutesFromStorage();
        });
    </script>

</body>
</html>
